/*********************************************************************/
/*                                                                   */
/* FILE         ism.cc                                               */
/* AUTHORS      Bastian Leibe                                        */
/* EMAIL        leibe@informatik.tu-darmstadt.de                     */
/*                                                                   */
/* CONTENT      Interleaved Object Categorization and Segmentation   */
/*              with an Implicit Shape Model.                        */
/*                                                                   */
/*              The class contains methods to perform simultaneous   */
/*              recognition and segmentation of canonical views of   */
/*              categorical objects, such as sideviews of cars or    */
/*              cows. Prior to recognition, a codebook of local ap-  */
/*              pearances (generated by the 'clusterer' program)     */
/*              must be loaded. Extracted image features are then    */
/*              matched to this codebook, thereby activating various */
/*              codebook entries. The list of activated codebook     */
/*              entries is passed as input to the ISM class.         */
/*                                                                   */
/*              In addition, the ISM class needs a file of 'occur-   */
/*              rences', i.e. of stored locations where codebook     */
/*              entries have been observed on the training objects,  */
/*              and of 'occurrence maps', i.e. the stored patch seg- */
/*              mentation masks for those locations, as extracted    */
/*              from reference segmentations for the training ima-   */
/*              ges. From this information, it generates first ini-  */
/*              tial hypotheses for possible object locations (and   */
/*              scales) in the image. For each of those hypotheses,  */
/*              it then computes an automatic top-down segmentation  */
/*              and uses this segmentation to again improve the      */
/*              hypotheses and resolve ambiguities between overlap-  */
/*              ping objects.                                        */
/*                                                                   */
/*              An explanation of the algorithm can be found in the  */
/*              following papers:                                    */
/*                                                                   */
/*              Bastian Leibe and Bernt Schiele,                     */
/*              Interleaved Object Categorization and Segmentation.  */
/*              In Proc. British Machine Vision Conference (BMVC'03) */
/*              Norwich, GB, Sept. 9-11, 2003.                       */
/*                                                                   */
/*              Bastian Leibe, Ales Leonardis, and Bernt Schiele,    */
/*              Combined Object Categorization and Segmentation with */
/*              an Implicit Shape Model.                             */
/*              in ECCV'04 Workshop on Statistical Learning in       */
/*              Computer Vision, Prague, May 2004.                   */
/*                                                                   */
/*              Bastian Leibe and Bernt Schiele,                     */
/*              Scale-Invariant Object Categorization using a Scale- */
/*              Adaptive Mean-Shift Search.                          */
/*              In Proc. DAGM'04 Pattern Recognition Symposium,      */
/*              Tuebingen, Germany, Aug. 2004. Springer LNCS,        */
/*              Vol. 3175, pp. 145--153, 2004.                       */
/*                                                                   */
/* BEGIN        Tue Nov 05 2002                                      */
/* LAST CHANGE  Thu Jan 20 2005                                      */
/*                                                                   */
/*********************************************************************/

/****************/
/*   Includes   */
/****************/
#include <iostream>
#include <iomanip>
#include <math.h>
#include <algorithm>

#include "occurrences.hh"
#include "ism.hh"
/*===================================================================*/
/*                         Global Function                           */
/*===================================================================*/
void convertl2v(const list<HoughVote>& lVotes, vector<HoughVote>& vVotes)
{
	for(list<HoughVote>::const_iterator it = lVotes.begin();it!=lVotes.end();it++)
		vVotes.push_back(*it);
	return;
}
void convertv2l(const vector<HoughVote>& vVotes, list<HoughVote>& lVotes)
{
	for(vector<HoughVote>::const_iterator it = vVotes.begin();it!=vVotes.end();it++)
		lVotes.push_back(*it);
	return;
}
/*===================================================================*/
/*===================================================================*/
/*                         Class Hypothesis                          */
/*===================================================================*/

void printHypothesis( Hypothesis hypo )
  /*******************************************************************/
  /* Print a hypothesis to stdout for debugging purposes.            */
  /*******************************************************************/
{
  cout << setw(5) << setprecision(5) << "  Score=" << hypo.dScore 
       << setw(2) << ": Pos(" << hypo.x << "," << hypo.y 
       << "), Cat.=" << hypo.nCategory 
       << setprecision(3) << ", Scale=" << hypo.dScale;
  if( hypo.dAngle!=0.0 )
    cout << ", Angle=" << hypo.dAngle;
  if( hypo.dAspect>=0.0 )
    cout << ", Aspect=" << hypo.dAspect;
  if( hypo.nPose >= 0 )
    cout << ", Pose=" << hypo.nPose;
  if( hypo.nTemplateId >= 0 )
    cout << ", TemplateId=" << hypo.nTemplateId;
  cout << endl;
}


void printHypothesisMDL( Hypothesis hypo )
  /*******************************************************************/
  /* Print a hypothesis to stdout for debugging purposes.            */
  /*******************************************************************/
{
  cout << setw(5) << setprecision(5) << "  Score=" << hypo.dScore 
       << " (MDL=" << hypo.dScoreMDL << ")"
       << setw(2) << ": Pos(" << hypo.x << "," << hypo.y 
       << "), Cat.=" << hypo.nCategory 
       << setprecision(3) << ", Scale=" << hypo.dScale;
  if( hypo.dAngle!=0.0 )
    cout << ", Angle=" << hypo.dAngle;
  if( hypo.dAspect>=0.0 )
    cout << ", Aspect=" << hypo.dAspect;
  if( hypo.nPose >= 0 )
    cout << ", Pose=" << hypo.nPose;
  if( hypo.nTemplateId >= 0 )
    cout << ", TemplateId=" << hypo.nTemplateId;
  cout << endl;
}


/*===================================================================*/
/*                             Class ISM                             */
/*===================================================================*/

/***********************************************************/
/*                      Constructors                       */
/***********************************************************/
ISM::ISM( int nCategory, int nCue ) 
{ 
  m_nCategory = nCategory; 
  m_nCue=nCue; 

  m_nNumOccs = 0;
}


/***********************************************************/
/*                    Access Functions                     */
/***********************************************************/


/***********************************************************/
/*                   Parameter Handling                    */
/***********************************************************/

void ISM::setRecoParams( RecoParams parReco )
{
  m_parReco = parReco;
}



/***********************************************************/
/*                      Occurrences                        */
/***********************************************************/

void ISM::initOccurrences( int nClusters )
{
  m_vvOccurrences.clear();
  vector< vector<ClusterOccurrence> > tmp( nClusters );
  m_vvOccurrences = tmp;
  m_vOccMaps.clear();
  m_nNumOccs = 0;
}


void ISM::addOccurrences ( const VecVecOccurrence    &vvOccurrences,
                           const vector<OpGrayImage> &vOccMaps,
                           int &nOccMapIdx )
/* Add a batch of new occurrences */
{
  assert( m_vvOccurrences.size() == vvOccurrences.size() );

  /* add the occurrences */
  for( int i=0; i<(int)vvOccurrences.size(); i++ )
    for( int j=0; j<(int)vvOccurrences[i].size(); j++ ) {
      m_vvOccurrences[i].push_back( vvOccurrences[i][j] );
      m_nNumOccs++;
    }

  /* add the occurrence maps */
  m_vOccMaps.insert( m_vOccMaps.end(), vOccMaps.begin(), vOccMaps.end() );

  /* update the map counter */
  nOccMapIdx = (int)m_vOccMaps.size();
}


void ISM::finishOccurrences()
{
  m_nNumOccs = 0;
  vector<float> vTmp( m_vvOccurrences.size() );
  m_vOccSumWeights = vTmp;
  for( int i=0; i<(int)m_vvOccurrences.size(); i++ ) {
    m_vOccSumWeights[i] = 0.0;
    m_nNumOccs += m_vvOccurrences[i].size();
    for( int j=0; j<(int)m_vvOccurrences[i].size(); j++ )
      m_vOccSumWeights[i] += m_vvOccurrences[i][j].dWeight;
  }
}


void ISM::loadOccurrences( string sFileName, int nNumClusters, bool bVerbose )
{
  m_nNumOccs = 0;
  int nResult = ::loadOccurrences( sFileName, nNumClusters, 
                                   m_vvOccurrences, bVerbose );
  if( nResult > 0 )
    m_nNumOccs = nResult;

  /* compute occurrence weights */
  vector<float> vTmp( m_vvOccurrences.size() );
  m_vOccSumWeights = vTmp;
  for( int i=0; i<(int)m_vvOccurrences.size(); i++ ) {
    m_vOccSumWeights[i] = 0.0;
    for( int j=0; j<(int)m_vvOccurrences[i].size(); j++ )
      m_vOccSumWeights[i] += m_vvOccurrences[i][j].dWeight;
  }

  /* try to load occurrence maps */
  ::loadOccurrenceMaps( sFileName, m_vOccMaps, bVerbose );
}


void ISM::saveOccurrences      ( string sFileName, bool bVerbose )
{
  ::saveOccurrences( sFileName, m_vvOccurrences, bVerbose );

  if( !m_vOccMaps.empty() )
    ::saveOccurrenceMaps( sFileName, m_vOccMaps, bVerbose );
}


void ISM::saveOccurrencesMatlab( string sFileName, bool bVerbose )
{
  ::saveOccurrencesMatlab( sFileName, m_vvOccurrences, bVerbose );
}


void ISM::removeOccurrences( const vector<bool> &vIdzs )
{
  if( vIdzs.size()!=m_vvOccurrences.size() ) {
    cerr << "ERROR in ISM::removeOccurrences(): "
         << "dimension of index vector doesn't match ("
         << vIdzs.size() << " instead of " << m_vvOccurrences.size()
         << ")!" << endl;
    return;
  }

  VecVecOccurrence vvNewOccs;
  for(unsigned i=0; i<vIdzs.size(); i++ )
    if( !vIdzs[i] )
      vvNewOccs.push_back( m_vvOccurrences[i] );

  m_vvOccurrences = vvNewOccs;
  finishOccurrences();
}


/***********************************************************/
/*                VotingSpace Initialization               */
/***********************************************************/

void ISM::clearVotingSpace()
{
  /***********************************/
  /*   Clear VotingSpace structure   */
  /***********************************/
  m_vsHoughVotes.clear();
}


void ISM::createVotingSpace  ( int nImgWidth, int nImgHeight, int nStepSize,
                               bool bVerbose )
{
  /****************************************/
  /*   Initialize VotingSpace structure   */
  /****************************************/
  m_vsHoughVotes.clear();
  VotingSpace vsTemp( nImgWidth/nStepSize,  0.0, (float) nImgWidth,
                      nImgHeight/nStepSize, 0.0, (float) nImgHeight );
  m_vsHoughVotes = vsTemp;

  if( bVerbose ) {
    cout << "  Debugging info for new VotingSpace:" 
         << endl;
    m_vsHoughVotes.print();
  }

  /*---------------------*/
  /* Set the Kernel type */
  /*---------------------*/
  int nKernelType = m_parReco.params()->m_nKernelType;
  switch( nKernelType ) {
  case KERNEL_HCUBE:
    m_vsHoughVotes.setKernelType( VotingSpace::KERNEL_HCUBE );
    break;

  case KERNEL_HSPHERE:
    m_vsHoughVotes.setKernelType( VotingSpace::KERNEL_HSPHERE );
    break;

  default:
    cerr << "Error in createVotingSpace(): "
         << "Unknown kernel type (" << nKernelType << ")!" << endl;
  }
}


void ISM::createVotingSpace  ( int nImgWidth, int nImgHeight, int nStepSize,
                               float dScaleMin, float dScaleMax, 
                               int nScaleSteps, bool bVerbose )
{
  /****************************************/
  /*   Initialize VotingSpace structure   */
  /****************************************/
  if( nScaleSteps == 0 )
    nScaleSteps = 1;

  m_vsHoughVotes.clear();
  VotingSpace vsTemp2( nImgWidth/nStepSize,  0.0, (float) nImgWidth,
                       nImgHeight/nStepSize, 0.0, (float) nImgHeight,
                       nScaleSteps, dScaleMin, dScaleMax );
  m_vsHoughVotes = vsTemp2;

  if( bVerbose ) {
    cout << "  Debugging info for new VotingSpace:" 
         << endl;
    m_vsHoughVotes.print();
  }

  /*---------------------*/
  /* Set the Kernel type */
  /*---------------------*/
  int nKernelType = m_parReco.params()->m_nKernelType;
  switch( nKernelType ) {
  case KERNEL_HCUBE:
    m_vsHoughVotes.setKernelType( VotingSpace::KERNEL_HCUBE );
    break;

  case KERNEL_HSPHERE:
    m_vsHoughVotes.setKernelType( VotingSpace::KERNEL_HSPHERE );
    break;

  default:
    cerr << "Error in createVotingSpace(): "
         << "Unknown kernel type (" << nKernelType << ")!" << endl;
  }
}


/***********************************************************/
/*                     Initial Voting                      */
/***********************************************************/

void ISM::doPatchVoting  ( const PointVector &vPoints,
                           MatchingInfo      &miMatching,
                           float dRejectionThresh,
                           bool bVerbose )
{
  doPatchVoting( vPoints, 
                 miMatching.getAllNeighbors(),
                 miMatching.getAllNeighborsSim(),
                 dRejectionThresh, bVerbose );
}


void ISM::doPatchVoting  ( const PointVector             &vPoints,
                           const vector< vector<int> >   &vvAllNeighbors, 
                           const vector< vector<float> > &vvAllNeighborsSim,
                           float dRejectionThresh,
                           bool bVerbose )
  /*******************************************************************/
  /* Collect all the patch votes for voting based on occurrences of  */
  /* codebook entries.                                               */
  /*******************************************************************/
{
  if( m_vvOccurrences.size() == 0 ) {
    cerr << "  No occurrences computed yet!" << endl;
    return;
  }
  if( !m_vsHoughVotes.isValid() ) {
    cerr << "  Error in ISM::doPatchVoting: "
         << "VotingSpace not properly initialized!" << endl;
    return;
  }

  switch( m_vsHoughVotes.numDims() ) {
  case 2:
    doPatchVoting2D( m_vsHoughVotes, 
                     vPoints, vvAllNeighbors, vvAllNeighborsSim,
                     1.0, dRejectionThresh, bVerbose );
    break;

  case 3:
    doPatchVoting3D( m_vsHoughVotes,
                     vPoints, vvAllNeighbors, vvAllNeighborsSim,
                     1.0, dRejectionThresh, bVerbose );
    break;

  default:
    cerr << "  Error in ISM::doPatchVoting: "
         << "VotingSpace dimensionality not supported ("<<  m_vsHoughVotes.numDims() << ")!" << endl;
  }
}


void ISM::doPatchVoting  ( VotingSpace &vsHoughVotes,
                           const PointVector             &vPoints,
                           MatchingInfo                  &miMatching,
                           float dPrior, float dRejectionThresh,
                           bool bVerbose )
  /*******************************************************************/
  /* Collect all the patch votes for voting based on occurrences of  */
  /* codebook entries.                                               */
  /* (This version of the function enters all votes into an external */
  /* voting space).                                                  */
  /*******************************************************************/
{
  doPatchVoting( vsHoughVotes, vPoints, 
                 miMatching.getAllNeighbors(),
                 miMatching.getAllNeighborsSim(),
                 dPrior, dRejectionThresh, bVerbose );
}


void ISM::doPatchVoting  ( VotingSpace &vsHoughVotes,
                           const PointVector             &vPoints,
                           const vector< vector<int> >   &vvAllNeighbors, 
                           const vector< vector<float> > &vvAllNeighborsSim,
                           float dPrior, float dRejectionThresh,
                           bool bVerbose )
  /*******************************************************************/
  /* Collect all the patch votes for voting based on occurrences of  */
  /* codebook entries.                                               */
  /* (This version of the function enters all votes into an external */
  /* voting space).                                                  */
  /*******************************************************************/
{
  if( m_vvOccurrences.size() == 0 ) {
    cerr << "  No occurrences computed yet!" << endl;
    return;
  }
  if( !vsHoughVotes.isValid() ) {
    cerr << "  Error in ISM::doPatchVoting: "
         << "VotingSpace not properly initialized!" << endl;
    return;
  }

  switch( vsHoughVotes.numDims() ) {
  case 2:
    doPatchVoting2D( vsHoughVotes, 
                     vPoints, vvAllNeighbors, vvAllNeighborsSim,
                     dPrior, dRejectionThresh, bVerbose );
    break;

  case 3:
    doPatchVoting3D( vsHoughVotes,
                     vPoints, vvAllNeighbors, vvAllNeighborsSim,
                     dPrior, dRejectionThresh, bVerbose );
    break;

  default:
    cerr << "  Error in ISM::doPatchVoting: "
         << "VotingSpace dimensionality not supported (" 
         << vsHoughVotes.numDims() << ")!" << endl;
  }
}


void ISM::doPatchVoting2D( VotingSpace                   &vsHoughVotes, 
                           const PointVector             &vPoints,
                           const vector< vector<int> >   &vvAllNeighbors, 
                           const vector< vector<float> > &vvAllNeighborsSim,
                           float dPrior, float dRejectionThresh,
                           bool bVerbose )
  /*******************************************************************/
  /* Collect all the patch votes for voting based on occurrences of  */
  /* codebook entries.                                               */
  /*******************************************************************/
{
  /*******************************************/
  /*   Create hypotheses for object center   */
  /*******************************************/
  /* always use all matches */
  for( int j=0; j<(int)vvAllNeighbors.size(); j++ ) 
    for( int k=0; k<(int)vvAllNeighbors[j].size(); k++ ) 
      if( vvAllNeighborsSim[j][k] > dRejectionThresh ) {
        /* for all activated clusters */
        int clusterId = vvAllNeighbors[j][k];
        float dVoteWeight = 1.0 / (float)vvAllNeighbors[j].size();

        /* process all valid hypotheses for this cluster */
        int nNumHypos = (int)m_vvOccurrences[clusterId].size();
        float dWeight = 1.0 / (float)( nNumHypos + m_vNegOccs[clusterId] );
        for( int kk=0; kk<nNumHypos; kk++ ) {
          if( m_vvOccurrences[clusterId][kk].dScale == 0.0 ) {
            cerr << "  Warning: occurrence " << k << " of cluster " 
                 << clusterId << " has scale zero!" << endl;
            cerr << "  Patch voting aborted." << endl;
            return;
          }

          float scale = ( vPoints[j].scale / 
                          m_vvOccurrences[clusterId][kk].dScale );
          float dOccWeight = m_vvOccurrences[clusterId][kk].dWeight;
          int posX = (int) floor( vPoints[j].x - 
                                  m_vvOccurrences[clusterId][kk].dPosX*scale );
          int posY = (int) floor( vPoints[j].y - 
                                  m_vvOccurrences[clusterId][kk].dPosY*scale );
          int nOccMapIdx = m_vvOccurrences[clusterId][kk].nOccMapIdx;
          vsHoughVotes.insertVote( HoughVote( (float)posX,
                                              (float)posY,
                                              (dWeight * dVoteWeight *
                                               dOccWeight * dPrior),
                                              (float)1.0,
                                              j, clusterId, kk, nOccMapIdx,
                                              m_nCue ) );
          
        }
      }
  if( bVerbose )
    cout << "  done." << endl;

  if( bVerbose ) {
    cout << "  Debugging info for VotingSpace vsHoughVotes:" << endl;
    vsHoughVotes.print();
    vsHoughVotes.printContent();
  }
}


void ISM::doPatchVoting3D( VotingSpace                   &vsHoughVotes, 
                           const PointVector             &vPoints,
                           const vector< vector<int> >   &vvAllNeighbors, 
                           const vector< vector<float> > &vvAllNeighborsSim,
                           float dPrior, float dRejectionThresh,
                           bool bVerbose )
  /*******************************************************************/
  /* Collect all the patch votes for voting based on occurrences of  */
  /* codebook entries (extended version for scale voting).           */
  /*******************************************************************/
{
  /******************************/
  /*   Prepare some variables   */
  /******************************/
  int nScaleSteps = vsHoughVotes.numBins ( 2 );

  float dScaleMin = vsHoughVotes.minValue( 2 );
  float dScaleMax = vsHoughVotes.maxValue( 2 );
  
  /*******************************************/
  /*   Create hypotheses for object center   */
  /*******************************************/
  float dScaleRange = dScaleMax - dScaleMin;
  if( dScaleRange == 0.0 )
    dScaleRange = 1.0;
  float dScaleCellSize = dScaleRange / ((float)nScaleSteps);  

  float dGibbsConst = -1.0 / ( m_parReco.params()->m_dGibbsConst*
                               log(dRejectionThresh) );

  /* always use all matches */
  if( bVerbose )
    cout << "  Filling in the voting space..." << endl;
  long nCountMatched = 0;
  long nCountVotes = 0;
  long nCountWeights = 0;
  long nCountAll = 0;
  for( unsigned j=0; j<vvAllNeighbors.size(); j++ ) {
     
    if(vvAllNeighbors[j].size()==0)
	continue;
    float dMatchWeight = 1.0 / (float)vvAllNeighbors[j].size();
    vector<float> vMatchWeight( vvAllNeighbors.size(), dMatchWeight );
    
    /*----------------------------------------*/
    /* Prepare the Gibbs distribution weights */
    /*----------------------------------------*/
    if( m_parReco.params()->m_nMatchWeighting==MATCHWEIGHT_GIBBS ) {
      float dSum=0.0;
      for( unsigned k=0; k<vvAllNeighbors[j].size(); k++ ) {
        vMatchWeight[k] = pow( vvAllNeighborsSim[j][k], dGibbsConst );
        dSum += vMatchWeight[k];
      }
      if( dSum>1.0 )
        for( unsigned k=0; k<vvAllNeighbors[j].size(); k++ )
          vMatchWeight[k] /= dSum;
    }  

    /*----------------*/
    /* Cast all votes */
    /*----------------*/
    for( unsigned k=0; k<vvAllNeighbors[j].size(); k++ ) 
      if( vvAllNeighborsSim[j][k] > dRejectionThresh ) {
        /* for all activated clusters */
        int clusterId = vvAllNeighbors[j][k];
        nCountMatched++;

        /* process all valid hypotheses for this cluster */
        int nNumHypos = (int)( m_vvOccurrences[clusterId].size() );
        if( nNumHypos == 0 ) {
//           cerr << "  Warning: No occurrences for cluster " << clusterId 
//                << "!" << endl;
//           cerr << "    Patch voting aborted for this cluster." << endl;
          continue;
        }
        
        /* compute the sum weight of the occurrences */
        float dSumWeight = m_vOccSumWeights[clusterId];
        
        //float dOccWeightNorm = 1.0/(float)(dSumWeight + vNegOccs[clusterId]);
        float dOccWeightNorm = 1.0 / dSumWeight;
        for( int kk=0; kk<nNumHypos; kk++ ) {
          if( m_vvOccurrences[clusterId][kk].dScale == 0.0 ) {
            cerr << "  Warning: occurrence " << kk << " of cluster " 
                 << clusterId << " has scale zero!" << endl;
            cerr << "  Patch voting aborted." << endl;
            return;
          }
          
          float dScale = ( vPoints[j].scale / 
                           m_vvOccurrences[clusterId][kk].dScale );
          float dAngle = ( vPoints[j].angle - 
                           m_vvOccurrences[clusterId][kk].dAngle );
          float dOccWeight = m_vvOccurrences[clusterId][kk].dWeight;
          int   nOccMapIdx = m_vvOccurrences[clusterId][kk].nOccMapIdx;

          nCountAll++;
          if( m_parReco.params()->m_bRestrictScale )
            /* if scale is out of range, don't store the vote */
            if( (dScale < dScaleMin - dScaleCellSize) || 
                (dScale > dScaleMax + dScaleCellSize) )
              continue;
          
          float dPosX, dPosY;
          if( !m_parReco.params()->m_bRecoRotInv ) {
            dPosX   = floor( vPoints[j].x - 
                             m_vvOccurrences[clusterId][kk].dPosX*dScale );
            dPosY   = floor( vPoints[j].y - 
                             m_vvOccurrences[clusterId][kk].dPosY*dScale );
          } else {
            float occx = m_vvOccurrences[clusterId][kk].dPosX;
            float occy = m_vvOccurrences[clusterId][kk].dPosY;
            float cosa = cos(dAngle);
            float sina = sin(dAngle);
            dPosX   = floor( vPoints[j].x - 
                             dScale*( occx*cosa + occy*sina ) );
            dPosY   = floor( vPoints[j].y - 
                             dScale*(-occx*sina + occy*cosa ) );
          }

          float dWeight = (vMatchWeight[k] * dOccWeight*dOccWeightNorm * 
                           dPrior);

          nCountWeights++;
          /* if vote weight is too small, don't store the vote */
          if(dWeight < m_parReco.params()->m_dMinVoteWeight)
            continue;

          /* if vote weight is too large, clip it */
          if( dWeight > m_parReco.params()->m_dMaxVoteWeight||!(dWeight ==dWeight ))
            dWeight = m_parReco.params()->m_dMaxVoteWeight;

          vsHoughVotes.insertVote( HoughVote( dPosX, dPosY, dScale,
                                              dWeight, 1.0, (int)j, 
                                              clusterId, kk, nOccMapIdx,
                                            m_nCue ) );
          if(dWeight < 0){
	    cout<<"   err: nagtive dWeight detected!" <<endl; 
	  }
          nCountVotes++;
        }
      } else {
        cerr << "    WARNING in ISM::doPatchVoting3D(): "
             << "vvAllNeighbors[" << j << "] contains non-matched elements!"
             << endl;
      }
  }
  
  if( bVerbose ) {
    cout << "    Generated " << nCountVotes << " votes." << endl;
    cout << "      from " << nCountMatched << " matched codebook entries." 
         << endl;
    if( m_parReco.params()->m_bRestrictScale )
      cout << "      (discarded " << nCountAll - nCountWeights 
           << " votes as outside of scale range)." << endl; 
    cout << "      (discarded " << nCountWeights - nCountVotes
         << " votes because of insufficient weight)." << endl; 
    cout << "  done." << endl;
  }
}


/***********************************************************/
/*                   Hypothesis Extraction                 */
/***********************************************************/

HypoVec ISM::getPatchHypotheses( const PointVector &vPoints,
                                 int   nStepSize,
                                 vector<OpGrayImage> &vImgVotes,
                                 bool bVerbose )
{
  HypoVec vEmpty;
  if( !m_vsHoughVotes.isValid() ) {
    cerr << "  Error in ISM::getPatchHypotheses(): "
         << "VotingSpace not properly initialized!" << endl;
    return vEmpty;
  }

  float dSearchRange = m_parReco.params()->m_dSearchRange;
  int   nObjWidth    = m_parReco.params()->m_nObjWidth;
  int   nObjHeight   = m_parReco.params()->m_nObjHeight;

  int   nAddedRangeX = ( ((int)((dSearchRange*nObjWidth) /
                                nStepSize)) * nStepSize );
  int   nAddedRangeY = ( ((int)((dSearchRange*nObjHeight) /
                                nStepSize)) * nStepSize );
  switch( m_vsHoughVotes.numDims() ) {
  case 2:
    return getPatchHypotheses2D( vPoints, nStepSize,
                                 false, nAddedRangeX, nAddedRangeY,
                                 vImgVotes, bVerbose );
    break;

  case 3:
    return getPatchHypotheses3D( vPoints, nStepSize,
                                 false, nAddedRangeX, nAddedRangeY,
                                 vImgVotes, bVerbose );
    break;

  default:
    cerr << "  Error in ISM::getPatchHypotheses: "
         << "VotingSpace dimensionality not supported (" 
         << m_vsHoughVotes.numDims() << ")!" << endl;
  }

  return vEmpty;
}


HypoVec ISM::getPatchHypotheses2D( const PointVector &vPoints,
                                   int   nStepSize,
                                   bool  bExtendSearch, 
                                   int   nAddedRangeX, int nAddedRangeY,
                                   vector<OpGrayImage>  &vImgVotes,
                                   bool bVerbose )
  /*******************************************************************/
  /* Extract all object hypotheses from the voting space as local    */
  /* maxima in the Hough accumulator array, the refine them using    */
  /* MSME.                                                           */
  /*******************************************************************/
{
  /******************************/
  /*   Prepare some variables   */
  /******************************/
  int nImgWidth   = (int) floor( m_vsHoughVotes.maxValue( 0 ) );
  int nImgHeight  = (int) floor( m_vsHoughVotes.maxValue( 1 ) );

  /*************************************/
  /*   Calculate patch voting scores   */
  /*************************************/
  /* search an extended range in order to find half-visible objects */
  if( !m_parReco.params()->m_bExtendSearch ) {
    nAddedRangeX = 0;
    nAddedRangeY = 0;
  }

  int minx = 0 - nAddedRangeX/nStepSize;
  int miny = 0 - nAddedRangeY/nStepSize;
  int maxx = (nImgWidth/nStepSize) + nAddedRangeX/nStepSize;
  int maxy = (nImgHeight/nStepSize)+ nAddedRangeY/nStepSize;

  float dCellSizeX = ( (float)nImgWidth  / (float)(nImgWidth/nStepSize) );
  float dCellSizeY = ( (float)nImgHeight / (float)(nImgHeight/nStepSize) );

  OpGrayImage imgVotes( maxx - minx, maxy - miny );
  m_vsHoughVotes.setWindowSize( m_parReco.params()->m_dMSMESizeX, 
                                m_parReco.params()->m_dMSMESizeY );
  if( bVerbose )
    cout << "  Collecting bin votes..." << endl;
  for( int y=miny, yy=0; y<maxy; y++, yy++ )
    for( int x=minx, xx=0; x<maxx; x++, xx++ ) {
      FeatureVector fvWindowPos( 2 );
      fvWindowPos.setValue( 0, (x+0.5)*dCellSizeX );
      fvWindowPos.setValue( 1, (y+0.5)*dCellSizeY );
      
      //imgVotes(xx,yy) = m_vsHoughVotes.getVoteSum( fvWindowPos );
      imgVotes(xx,yy) = m_vsHoughVotes.getBinVoteSum(x,y);
    }
  vImgVotes.push_back( imgVotes );
  if( bVerbose )
    cout << "  done." << endl;
  

  /******************************/
  /*   Find local vote maxima   */
  /******************************/
  OpGrayImage imgMaxima = imgVotes.opNonMaximumSuppression();

  /* find the maximum vote value */
  float min, max;
  imgMaxima.getMinMax( min, max );


  /************************************/
  /*   Refine the maxima using MSME   */
  /************************************/
  HypoVec vHypotheses;
  float dThresh = m_parReco.params()->m_dScoreThreshSingle;
  if( bVerbose )
    cout << "  Extracting maxima..." << endl;
  for( int y=0; y<imgMaxima.height(); y++ )
    for( int x=0; x<imgMaxima.width(); x++ )
      if( (imgMaxima(x,y).value() >= 0.1*max) &&
          (imgMaxima(x,y).value() >= 0.9*dThresh) ) {
        /*------------------------------------*/
        /* NEW: refine the maximum using MSME */
        /*------------------------------------*/
        FeatureVector fvStart( 2 );
        fvStart.setValue( 0, (x-nAddedRangeX/nStepSize+0.5)*dCellSizeX );
        fvStart.setValue( 1, (y-nAddedRangeY/nStepSize+0.5)*dCellSizeY );

        FeatureVector fvResult( 2 );
        float dScore;
        m_vsHoughVotes.applyMSME( fvStart, fvResult, dScore );
       
        Hypothesis newHypo;
        newHypo.x           = (int)fvResult.at(0);
        newHypo.y           = (int)fvResult.at(1);
        newHypo.dScore      = dScore;
        newHypo.dScale      = 1.0;
        newHypo.nCategory   = m_nCategory;
        newHypo.nPose       = -1;
        newHypo.dAngle      = 0.0;
        newHypo.dAspect     = -1.0;
        newHypo.bPoseFlipped= false;
        newHypo.nTemplateId = -1;
        newHypo.dAreaFactor = 1.0;
        newHypo.dRealDist   = -1.0;
        newHypo.dRealSize   = -1.0;

        vHypotheses.push_back( newHypo );
      }
  if( bVerbose )
    cout << "  done." << endl;
 
  /* sort the hypothesis list */
  int numHypos = vHypotheses.size();
	for( int j=0; j<numHypos-1; j++ )
		for( int i=1; i<numHypos-j; i++ )
			if( vHypotheses[i].dScore > vHypotheses[i-1].dScore ) {
				Hypothesis tmp = vHypotheses[i-1];
				vHypotheses[i-1] = vHypotheses[i];
				vHypotheses[i] = tmp;
			}


  if( bVerbose ) {
    cout << "=======================================" << endl;
    cout << "Single-Patch Voting Hypotheses:" << endl;
    for( int i=0; i<(int)vHypotheses.size(); i++ ) {
      cout << "  " << setw(2) << i+1 << ". ";
      printHypothesis( vHypotheses[i] );
    }
    cout << "=======================================" << endl;
    cout << endl;
  }

  return vHypotheses;
}
  

HypoVec ISM::getPatchHypotheses3D( const PointVector &vPoints,
                                   int   nStepSize,
                                   bool  bExtendSearch, 
                                   int   nAddedRangeX, 
                                   int   nAddedRangeY,
                                   vector<OpGrayImage>  &vImgVotes,
                                   bool bVerbose )
  /*******************************************************************/
  /* Extract all object hypotheses from the voting space as local    */
  /* maxima in the Hough accumulator array, then refine them using   */
  /* MSME (extended version for scale search).                       */
  /*******************************************************************/
{
  /******************************/
  /*   Prepare some variables   */
  /******************************/
  int nImgWidth   = (int) floor( m_vsHoughVotes.maxValue( 0 ) );
  int nImgHeight  = (int) floor( m_vsHoughVotes.maxValue( 1 ) );

  //float dScaleMin   = m_vsHoughVotes.minValue( 2 );
  //float dScaleMax   = m_vsHoughVotes.maxValue( 2 );
  //int nScaleSteps   = m_vsHoughVotes.numBins( 2 );

  // scale parameters
  float dRecoScaleMin = m_parReco.params()->m_dRecoScaleMin;
  float dRecoScaleMax = m_parReco.params()->m_dRecoScaleMax;
  float dMSMESizeS    = m_parReco.params()->m_dMSMESizeS;

  int   nScaleSteps   = (int)floor((dRecoScaleMax - dRecoScaleMin)/
                                   dMSMESizeS) + 1;
  float dScaleMin     = dRecoScaleMin - dMSMESizeS/2.0;
  float dScaleMax     = dRecoScaleMax + dMSMESizeS/2.0;

  float dScaleRange = dScaleMax - dScaleMin;
  if( nScaleSteps == 0 ) nScaleSteps = 1;

  // rotation parameters
  float dRecoRotMin   = m_parReco.params()->m_dRecoRotMin*(M_PI/180.0);
  float dRecoRotMax   = m_parReco.params()->m_dRecoRotMax*(M_PI/180.0);
  float dMSMESizeR    = m_parReco.params()->m_dMSMESizeR*(M_PI/180.0);

  int   nRotSteps     = (int)floor((dRecoRotMax - dRecoRotMin)/dMSMESizeR) + 1;
  float dRotMin       = (dRecoRotMin - dMSMESizeR/2.0);
  float dRotMax       = (dRecoRotMax + dMSMESizeR/2.0);

  float dRotRange     = dRotMax - dRotMin;
  if( nRotSteps == 0 ) nRotSteps = 1;

  // aspect parameters
  float dRecoAspMin   = m_parReco.params()->m_dRecoAspMin*(M_PI/180.0);
  float dRecoAspMax   = m_parReco.params()->m_dRecoAspMax*(M_PI/180.0);
  float dMSMESizeA    = m_parReco.params()->m_dMSMESizeA*(M_PI/180.0);

  int   nAspSteps     = (int)floor((dRecoAspMax - dRecoAspMin)/dMSMESizeA) + 1;
  float dAspMin       = (dRecoAspMin - dMSMESizeA/2.0);
  float dAspMax       = (dRecoAspMax + dMSMESizeA/2.0);

  float dAspRange     = dAspMax - dAspMin;
  if( nAspSteps == 0 ) nAspSteps = 1;

  float dCellSizeX = ( (float)nImgWidth  / (float)(nImgWidth/nStepSize) );
  float dCellSizeY = ( (float)nImgHeight / (float)(nImgHeight/nStepSize) );
  float dCellSizeS = ( dScaleRange / (float)nScaleSteps );
  float dCellSizeR = ( dRotRange / (float)nRotSteps );
  float dCellSizeA = ( dAspRange / (float)nAspSteps );

  /* search an extended range in order to find half-visible objects */
  if( !m_parReco.params()->m_bExtendSearch ) {
    nAddedRangeX = 0;
    nAddedRangeY = 0;
  }

  int minx = 0 - nAddedRangeX/nStepSize;
  int miny = 0 - nAddedRangeY/nStepSize;
  int maxx = (nImgWidth/nStepSize) + nAddedRangeX/nStepSize;
  int maxy = (nImgHeight/nStepSize)+ nAddedRangeY/nStepSize;

  /*************************************/
  /*   Calculate patch voting scores   */
  /*************************************/
  OpGrayImage tmpImg( maxx - minx, maxy - miny );
  vector<OpGrayImage> tmpVec( nScaleSteps, tmpImg );
  vImgVotes  = tmpVec;
  vector<OpGrayImage> vImgMaxima = tmpVec;

  m_vsHoughVotes.setWindowSize( m_parReco.params()->m_dMSMESizeX, 
                                m_parReco.params()->m_dMSMESizeY, 
                                m_parReco.params()->m_dMSMESizeS );

  if( bVerbose ) {
    cout << "  Collecting bin votes..." << endl;
    if( m_parReco.params()->m_bUseFastMSME )
    cout << "    (using fast approximate MSME)" << endl;
  }
  long nCountEmpty = 0;
  for( int y=miny, yy=0; y<maxy; y++, yy++ )
    for( int x=minx, xx=0; x<maxx; x++, xx++ )
      for( int s=0; s<nScaleSteps; s++ ) {
        FeatureVector fvWindowPos( 3 );
        fvWindowPos.setValue( 0, (x+0.5)*dCellSizeX );
        fvWindowPos.setValue( 1, (y+0.5)*dCellSizeY );
        fvWindowPos.setValue( 2, dScaleMin+(s+0.5)*dCellSizeS );
      
        /* use scale-adapted window size */
        FeatureVector fvWindowSize = getAdaptiveWinSize( fvWindowPos );
        m_vsHoughVotes.setWindowSize( fvWindowSize );

        float dVoteSum;
        if( !m_parReco.params()->m_bUseFastMSME )
          dVoteSum = m_vsHoughVotes.getVoteSum(fvWindowPos); 
        else
          m_vsHoughVotes.getFastKernelVoteSum( x, y, s, dVoteSum );

        vImgVotes[s](xx,yy) = dVoteSum;
        if( dVoteSum <= MIN_VOTE_WEIGHT ) 
          nCountEmpty++;
        //vImgVotes[s](xx,yy) = m_vsHoughVotes.getBinVoteSum(x,y,s);
    }
  if( bVerbose ) {
    cout << "  done." << endl;
    cout << "    (" << nCountEmpty << " out of " 
         << (maxy-miny)*(maxx-minx)*nScaleSteps << " bins were empty)." 
         << endl;
  }
  
  /******************************/
  /*   Find local vote maxima   */
  /******************************/
  if( bVerbose )
    cout << "  Refining candidate maxima..." << endl;
  for( int s=0; s<nScaleSteps; s++ )
    // !!! should be opNonMaximumSuppresion3D !!!
    vImgMaxima[s] = vImgVotes[s].opNonMaximumSuppression();

  /* find the maximum vote value for this image */
  float min, max;
  vImgMaxima[0].getMinMax( min, max );
  for( int s=1; s<nScaleSteps; s++ ) {
    float min_in_scale, max_in_scale;
    vImgMaxima[s].getMinMax( min_in_scale, max_in_scale );

    if( min_in_scale < min )
      min = min_in_scale;
    if( max_in_scale > max )
      max = max_in_scale;
  }

  /************************************/
  /*   Refine the maxima using MSME   */
  /************************************/
  float dMSMESizeX = m_parReco.params()->m_dMSMESizeX;
  float dMSMESizeY = m_parReco.params()->m_dMSMESizeY;
  //float dMSMESizeS = m_parReco.params()->m_dMSMESizeS;
  bool  bAdaptiveScale = m_parReco.params()->m_bAdaptiveScale;
  float dAdaptMinScale = m_parReco.params()->m_dAdaptMinScale;
  HypoVec vHypotheses;
  float dThresh = m_parReco.params()->m_dScoreThreshSingle;
  m_vsHoughVotes.setWindowSize( dMSMESizeX, dMSMESizeY, dMSMESizeS );
  for( int s=0; s<nScaleSteps; s++ )
    for( int y=0; y<vImgMaxima[s].height(); y++ )
      for( int x=0; x<vImgMaxima[s].width(); x++ )
        if( (vImgMaxima[s](x,y).value() >= 0.15*max) && 
            (vImgMaxima[s](x,y).value() >= 0.9*dThresh) ) {
          /*-------------------------------*/
          /* Refine the maximum using MSME */
          /*-------------------------------*/
          FeatureVector fvStart( 3 );
          fvStart.setValue( 0, (x-nAddedRangeX/nStepSize+0.5)*dCellSizeX );
          fvStart.setValue( 1, (y-nAddedRangeY/nStepSize+0.5)*dCellSizeY );
          fvStart.setValue( 2, dScaleMin+(s+0.5)*dCellSizeS );
          
          FeatureVector fvResult( 3 );
          float dScore;
          
          //m_vsHoughVotes.applyMSME( fvStart, fvResult, dScore, 
          //                          bAdaptiveScale, dAdaptMinScale,
          //                          m_parReco.params()->m_bUseFastMSME );
          m_vsHoughVotes.applyMSME( fvStart, fvResult, dScore, 
                                    bAdaptiveScale, dAdaptMinScale );

          if( dScore >= 0.9*dThresh ) {
            Hypothesis newHypo;
            newHypo.x           = (int)fvResult.at(0);
            newHypo.y           = (int)fvResult.at(1);
            newHypo.dScale      = (float)fvResult.at(2);
            newHypo.dScore      = dScore;
            newHypo.nCategory   = m_nCategory;
            newHypo.nPose       = -1;
            newHypo.dAngle      = 0.0;
            newHypo.dAspect     = -1.0;
            newHypo.bPoseFlipped= false;
            newHypo.nTemplateId = -1;
            newHypo.dAreaFactor = 1.0;
            newHypo.dRealDist   = -1.0;
            newHypo.dRealSize   = -1.0;
                    
            vHypotheses.push_back( newHypo );
          }
        }
  
  /*************************************/
  /*   Recover the dominant rotation   */
  /*************************************/
  if( m_parReco.params()->m_bRecoverRotation ) {
    if( bVerbose )
      cout << "  Recovering rotation..." << endl;
 
    HypoVec vHyposRot;
    for( int j=0; j<(int)vHypotheses.size(); j++ ) {
      //cout << "    Hypothesis " << j << ": ";
      /* Get the supporting votes for this hypothesis */
      list<HoughVote> vSupporting;
      
      vSupporting = m_vsHoughVotes.getSupportingVotes( vHypotheses[j].x, 
                                                       vHypotheses[j].y,
                                                       vHypotheses[j].dScale );
      //cout << vSupporting.size() << " votes." << endl;

      /* Create a 1D rotation voting space */
      //cout << "      Creating voting space (" << nRotSteps << "," << dRotMin
      //     << "," << dRotMax << ")..." << endl;
      VotingSpace vsRotVotes( nRotSteps, dRotMin, dRotMax );

      /* Fill in the votes to the 1D voting space */
      //cout << "      Filling in the votes: " << endl;
//       for( int k=0; k<(int)vSupporting.size(); k++ ) {
      for( list<HoughVote>::iterator it=vSupporting.begin(); 
           it!=vSupporting.end(); it++ ) {
        int   nImgPointId = it->getImgPointId();
        int   nClusterId  = it->getClusterId();
        int   nOccNumber  = it->getOccNumber(); 
        float dWeight     = it->getValue();
        float dAngle = ( vPoints[nImgPointId].angle - 
                         m_vvOccurrences[nClusterId][nOccNumber].dAngle ); 
        //cout << dAngle << " ";
        vsRotVotes.insertVote( HoughVote( dAngle, dWeight, 1.0,
                                          nImgPointId, nClusterId, 
                                          nOccNumber, m_nCue) );
      }
      //cout << endl;

      /* Search for the maximum in the rotation space */
      //cout << "      Searching for a maximum..." << endl;
      vsRotVotes.setWindowSize( dMSMESizeR );
      float dMaxVal   = 0.0;
      float dMaxAngle = 0.0;
      //cout << "        vs=[ ";
      for( int r=0; r<nRotSteps; r++ ) {
        float dAngle = dRotMin+(r+0.5)*dCellSizeR;
        float dVoteSum;
        if( !m_parReco.params()->m_bUseFastMSME )
          dVoteSum = vsRotVotes.getVoteSum( dAngle ); 
        else
          vsRotVotes.getFastKernelVoteSum( r, dVoteSum );
        //cout << dVoteSum << " ";

        if( dVoteSum > dMaxVal ) {
          dMaxVal   = dVoteSum;
          dMaxAngle = dAngle;
        }
      }
      //cout << " ]" << endl;
      //cout << "        found maximum: angle=" << dMaxAngle 
      //     << ", score=" << dMaxVal << endl;
      
      /* Refine the maximum using MSME */
      //cout << "      Refining with MSME..." << endl;
      FeatureVector fvResult( 1 );
      float dScore;
      vsRotVotes.applyMSME( dMaxAngle, fvResult, dScore, false );
      //cout << "        refined maximum: angle=" << fvResult.at(0) 
      //     << ", score=" << dScore << endl;

      if( dScore >= 0.9*dThresh ) {
        vHypotheses[j].dAngle = fvResult.at(0);
        vHypotheses[j].dScore = dScore;
        vHyposRot.push_back( vHypotheses[j] );
      }
    }
    vHypotheses = vHyposRot;
  }

  /***********************************/
  /*   Recover the dominant aspect   */
  /***********************************/
  // CAUTION: version still incomplete -- does not work in conjunction
  // with rotation recovery! I still need to fix this!
  if( m_parReco.params()->m_bUseAspect ) {
    if( bVerbose )
      cout << "  Recovering aspect..." << endl;
 
    HypoVec vHyposAsp;
    for( int j=0; j<(int)vHypotheses.size(); j++ ) {
      //cout << "    Hypothesis " << j << ": ";
      /* Get the supporting votes for this hypothesis */
      list<HoughVote> vSupporting;
      vSupporting = m_vsHoughVotes.getSupportingVotes( vHypotheses[j].x, 
                                                       vHypotheses[j].y,
                                                       vHypotheses[j].dScale );
      //cout << vSupporting.size() << " votes." << endl;

      /* Create a 1D aspect voting space */
      //cout << "      Creating voting space (" << nAspSteps << "," << dAspMin
      //     << "," << dAspMax << ")..." << endl;
      VotingSpace vsAspVotes( nAspSteps, dAspMin, dAspMax );

      /* Fill in the votes to the 1D voting space */
      //cout << "      Filling in the votes: " << endl;
//       for( int k=0; k<(int)vSupporting.size(); k++ ) {
      for( list<HoughVote>::iterator it=vSupporting.begin();
           it!=vSupporting.end(); it++ ) {
        int   nImgPointId = it->getImgPointId();
        int   nClusterId  = it->getClusterId();
        int   nOccNumber  = it->getOccNumber(); 
        int   nOccMapIdx  = m_vvOccurrences[nClusterId][nOccNumber].nOccMapIdx;
        float dWeight     = it->getValue();
        float dBBRatio    = -1.0;
        if( nClusterId>0 && nClusterId<(int)m_vvOccurrences.size() )
          if( nOccNumber>0 && 
              nOccNumber<(int)m_vvOccurrences[nClusterId].size() )
            dBBRatio    = m_vvOccurrences[nClusterId][nOccNumber].dBBRatio;
        //float dBBRatio    = m_vvOccurrences[nClusterId][nOccNumber].dBBRatio;
        float dAspect     = -1.0;
        if( dBBRatio>0.0 ) {
          dAspect = atan(dBBRatio);
          //cout << dAspect << "  ";
          vsAspVotes.insertVote( HoughVote( dAspect, dWeight, 1.0,
                                            nImgPointId, nClusterId, 
                                            nOccNumber, nOccMapIdx, m_nCue) );
        }
      }
      //cout << endl;

      /* Search for the maximum in the rotation space */
      //cout << "      Searching for a maximum..." << endl;
      vsAspVotes.setWindowSize( dMSMESizeA );
      float dMaxVal    = 0.0;
      float dMaxAspect = 0.0;
      //cout << "        vs=[ ";
      for( int a=0; a<nAspSteps; a++ ) {
        float dAspect = dAspMin+(a+0.5)*dCellSizeA;
        float dVoteSum;
        if( !m_parReco.params()->m_bUseFastMSME )
          dVoteSum = vsAspVotes.getVoteSum( dAspect ); 
        else
          vsAspVotes.getFastKernelVoteSum( a, dVoteSum );
        //cout << dVoteSum << " ";

        if( dVoteSum > dMaxVal ) {
          dMaxVal    = dVoteSum;
          dMaxAspect = dAspect;
        }
      }
      //cout << " ]" << endl;
      //cout << "        found maximum: aspect=" << dMaxAspect 
      //     << ", score=" << dMaxVal << endl;
      
      /* Refine the maximum using MSME */
      //cout << "      Refining with MSME..." << endl;
      FeatureVector fvResult( 1 );
      float dScore;
      vsAspVotes.applyMSME( dMaxAspect, fvResult, dScore, false );
      //cout << "        refined maximum: aspect=" << fvResult.at(0) 
      //     << ", score=" << dScore << endl;

      if( dScore >= 0.9*dThresh ) {
        vHypotheses[j].dAspect = tan(fvResult.at(0));
        vHypotheses[j].dScore = dScore;
        vHyposAsp.push_back( vHypotheses[j] );
      }
    }
    vHypotheses = vHyposAsp;
  }

  /********************************/
  /*   Sort the hypothesis list   */
  /********************************/
  int numHypos = vHypotheses.size();
	for( int j=0; j<numHypos-1; j++ )
		for( int i=1; i<numHypos-j; i++ )
			if( vHypotheses[i].dScore > vHypotheses[i-1].dScore ) {
				Hypothesis tmp = vHypotheses[i-1];
				vHypotheses[i-1] = vHypotheses[i];
				vHypotheses[i] = tmp;
			}

  if( bVerbose ) 
    cout << "  done." << endl;

  if( bVerbose ) {
    cout << "=======================================" << endl;
    cout << "Single-Patch Voting Hypotheses:" << endl;
    for( int i=0; i<(int)vHypotheses.size(); i++ ) {
      cout << "  " << setw(2) << i+1 << ". ";
      printHypothesis( vHypotheses[i] );
    }
    cout << "=======================================" << endl;
    cout << endl;
  }

  return vHypotheses;
}
  

/***********************************************************/
/*                   Hypothesis Refinement                 */
/***********************************************************/

HypoVec ISM::refinePatchHypotheses( const HypoVec     &vInitialHypos,
                                    const PointVector &vPoints,
                                    bool bVerbose )
{
  HypoVec vEmpty;
  if( !m_vsHoughVotes.isValid() ) {
    cerr << "  Error in ISM::refinePatchHypotheses(): "
         << "VotingSpace not properly initialized!" << endl;
    return vEmpty;
  }

  switch( m_vsHoughVotes.numDims() ) {
  case 2:
    return refinePatchHypotheses2D( vInitialHypos, vPoints, bVerbose );
    break;

  case 3:
    return refinePatchHypotheses3D( vInitialHypos, vPoints, bVerbose );
    break;

  default:
    cerr << "  Error in ISM::refinePatchHypotheses: "
         << "VotingSpace dimensionality not supported (" 
         << m_vsHoughVotes.numDims() << ")!" << endl;
  }  

  return vEmpty;
}


HypoVec ISM::refinePatchHypotheses2D( const HypoVec     &vInitialHypos,
                                      const PointVector &vPoints,
                                      bool bVerbose )
  /*******************************************************************/
  /* Refine the given object hypotheses in the 2D voting space using */
  /* MSME.                                                          */
  /*******************************************************************/
{
  /**************************/
  /* Prepare some variables */
  /**************************/
  //int nImgWidth   = (int) floor( m_vsHoughVotes.maxValue( 0 ) );
  //int nImgHeight  = (int) floor( m_vsHoughVotes.maxValue( 1 ) );

  /*****************************************/
  /* Refine the given hypothesis locations */
  /*****************************************/
  HypoVec vHypotheses;
  m_vsHoughVotes.setWindowSize( m_parReco.params()->m_dMSMESizeX, 
                                m_parReco.params()->m_dMSMESizeY );
  for( int i=0; i<(int)vInitialHypos.size(); i++ ) {
    int x = vInitialHypos[i].x;
    int y = vInitialHypos[i].y;

    /*--------------------------------*/
    /* refine the location using MSME */
    /*--------------------------------*/
    FeatureVector fvStart( 2 );
    fvStart.setValue( 0, x );
    fvStart.setValue( 1, y ); 

    FeatureVector fvResult( 2 );
    float dScore;
    m_vsHoughVotes.applyMSME( fvStart, fvResult, dScore );
       
    Hypothesis newHypo;
    newHypo.x           = (int)fvResult.at(0);
    newHypo.y           = (int)fvResult.at(1);
    newHypo.dScore      = dScore;
    newHypo.dScale      = 1.0;
    newHypo.nCategory   = m_nCategory;
    newHypo.nPose       = -1;
    newHypo.dAngle      = 0.0;
    newHypo.dAspect     = -1.0;
    newHypo.bPoseFlipped= false;
    newHypo.nTemplateId = -1;
    newHypo.dAreaFactor = 1.0;
    newHypo.dRealDist   = -1.0;
    newHypo.dRealSize   = -1.0;
    
    vHypotheses.push_back( newHypo );
  }

  /* sort the hypothesis list */
  int numHypos = vHypotheses.size();
	for( int j=0; j<numHypos-1; j++ )
		for( int i=1; i<numHypos-j; i++ )
			if( vHypotheses[i].dScore > vHypotheses[i-1].dScore ) {
				Hypothesis tmp = vHypotheses[i-1];
				vHypotheses[i-1] = vHypotheses[i];
				vHypotheses[i] = tmp;
			}

  if( bVerbose ) {
    cout << "=======================================" << endl;
    cout << "Refined Single-Patch Hypotheses:" << endl;
    for( int i=0; i<(int)vHypotheses.size(); i++ ) {
      cout << "  " << setw(2) << i+1 << ". ";
      printHypothesis( vHypotheses[i] );
    }
    cout << "=======================================" << endl;
    cout << endl;
  }

  return vHypotheses;
}
  

HypoVec ISM::refinePatchHypotheses3D( const HypoVec     &vInitialHypos,
                                      const PointVector &vPoints,
                                     bool bVerbose )
  /*******************************************************************/
  /* Refine the given object hypotheses in the 3D voting space using */
  /* MSME.                                                          */
  /*******************************************************************/
{
  /**************************/
  /* Prepare some variables */
  /**************************/
  //int nImgWidth   = (int) floor( m_vsHoughVotes.maxValue( 0 ) );
  //int nImgHeight  = (int) floor( m_vsHoughVotes.maxValue( 1 ) );

  /*****************************************/
  /* Refine the given hypothesis locations */
  /*****************************************/
  HypoVec vHypotheses;
  m_vsHoughVotes.setWindowSize( m_parReco.params()->m_dMSMESizeX, 
                                m_parReco.params()->m_dMSMESizeY, 
                                m_parReco.params()->m_dMSMESizeS );
  for( int i=0; i<(int)vInitialHypos.size(); i++ ) {
    int x       = vInitialHypos[i].x;
    int y       = vInitialHypos[i].y;
    float scale = vInitialHypos[i].dScale;
    
    /*--------------------------------*/
    /* refine the location using MSME */
    /*--------------------------------*/
    FeatureVector fvStart( 3 );
    fvStart.setValue( 0, x );
    fvStart.setValue( 1, y ); 
    fvStart.setValue( 2, scale ); 

    FeatureVector fvResult( 3 );
    float dScore;
    m_vsHoughVotes.applyMSME( fvStart, fvResult, dScore );
       
    Hypothesis newHypo;
    newHypo.x           = (int)fvResult.at(0);
    newHypo.y           = (int)fvResult.at(1);
    newHypo.dScale      = fvResult.at(2);
    newHypo.dScore      = dScore;
    newHypo.nCategory   = m_nCategory;
    newHypo.nPose       = -1;
    newHypo.dAngle      = 0.0;
    newHypo.dAspect     = -1.0;
    newHypo.bPoseFlipped= false;
    newHypo.nTemplateId = -1;
    newHypo.dAreaFactor = 1.0;
    newHypo.dRealDist   = -1.0;
    newHypo.dRealSize   = -1.0;

    vHypotheses.push_back( newHypo );
  }
  
  /* sort the hypothesis list */
  int numHypos = vHypotheses.size();
	for( int j=0; j<numHypos-1; j++ )
		for( int i=1; i<numHypos-j; i++ )
			if( vHypotheses[i].dScore > vHypotheses[i-1].dScore ) {
				Hypothesis tmp = vHypotheses[i-1];
				vHypotheses[i-1] = vHypotheses[i];
				vHypotheses[i] = tmp;
			}

  if( bVerbose ) {
  cout << "=======================================" << endl;
  cout << "Refined Single-Patch Hypotheses:" << endl;
  for( int i=0; i<(int)vHypotheses.size(); i++ ) {
      cout << "  " << setw(2) << i+1 << ". ";
      printHypothesis( vHypotheses[i] );
    }
    cout << "=======================================" << endl;
    cout << endl;
  }

  return vHypotheses;
}
  

/***********************************************************/
/*                    Supporting Votes                     */
/***********************************************************/
vector<HoughVote> ISM::getSupportingVotes_v( float x, float y )
{
  vector<HoughVote> vResult;

  if( !m_vsHoughVotes.isValid() ) {
    cerr << "  Error in ISM::getSupportingVotes_v(): "
         << "VotingSpace not properly initialized!" << endl;
    return vResult;
  }
  if( m_vsHoughVotes.numDims()!=2 ) {
    cerr << "  Error in ISM::getSupportingVotes_v(): "
         << "VotingSpace has wrong dimensionality!" << endl;
    return vResult;
  }

  FeatureVector fvWindowPos( 2 );
  fvWindowPos.setValue( 0, x );
  fvWindowPos.setValue( 1, y );

  FeatureVector fvWindowSize = getAdaptiveWinSize( fvWindowPos );
  return  getSupportingVotes_v( fvWindowPos, fvWindowSize );
}


vector<HoughVote> ISM::getSupportingVotes_v( float x, float y, float s )
{
  vector<HoughVote> vResult;

  if( !m_vsHoughVotes.isValid() ) {
    cerr << "  Error in ISM::getSupportingVotes()_v: "
         << "VotingSpace not properly initialized!" << endl;
    return vResult;
  }
  if( m_vsHoughVotes.numDims()!=3 ) {
    cerr << "  Error in ISM::getSupportingVotes()_v: "
         << "VotingSpace has wrong dimensionality!" << endl;
    return vResult;
  }

  FeatureVector fvWindowPos( 3 );
  fvWindowPos.setValue( 0, x );
  fvWindowPos.setValue( 1, y );
  fvWindowPos.setValue( 2, s );

  FeatureVector fvWindowSize = getAdaptiveWinSize( fvWindowPos );
  return  getSupportingVotes_v( fvWindowPos, fvWindowSize );
}


vector<HoughVote> ISM::getSupportingVotes_v( FeatureVector fvWindowPos )
{
  vector<HoughVote> vResult;

  if( !m_vsHoughVotes.isValid() ) {
    cerr << "  Error in ISM::getSupportingVotes_v(): "
         << "VotingSpace not properly initialized!" << endl;
    return vResult;
  }
  if( m_vsHoughVotes.numDims()!=fvWindowPos.numDims() ) {
    cerr << "  Error in ISM::getSupportingVotes_v(): "
         << "VotingSpace has wrong dimensionality!" << endl;
    return vResult;
  }

  FeatureVector fvWindowSize = getAdaptiveWinSize( fvWindowPos );
  return  getSupportingVotes_v( fvWindowPos, fvWindowSize );
}


vector<HoughVote> ISM::getSupportingVotes_v( FeatureVector fvWindowPos,
                                           FeatureVector fvWindowSize )
{
  vector<HoughVote> vResult;

  if( !m_vsHoughVotes.isValid() ) {
    cerr << "  Error in ISM::getSupportingVotes_v(): "
         << "VotingSpace not properly initialized!" << endl;
    return vResult;
  }
  if( m_vsHoughVotes.numDims()!=fvWindowPos.numDims() ) {
    cerr << "  Error in ISM::getSupportingVotes_v(): "
         << "VotingSpace has wrong dimensionality!" << endl;
    return vResult;
  }

  /* set the window size */
  m_vsHoughVotes.setWindowSize( fvWindowSize );
  
 /* set the Kernel type */
  int nKernelType = m_parReco.params()->m_nKernelType;
  switch( nKernelType ) {
  case KERNEL_HCUBE:
    m_vsHoughVotes.setKernelType( VotingSpace::KERNEL_HCUBE );
    break;

  case KERNEL_HSPHERE:
    m_vsHoughVotes.setKernelType( VotingSpace::KERNEL_HSPHERE );
    break;

  default:
    cerr << "Error in getSupportingVotes(): "
         << "Unknown kernel type (" << nKernelType << ")!" << endl;
  }
  list<HoughVote> lResult;
  lResult   = m_vsHoughVotes.getSupportingVotes( fvWindowPos );
  convertl2v(lResult,vResult);
  
  return vResult;
}
list<HoughVote> ISM::getSupportingVotes( float x, float y )
{
  list<HoughVote> vResult;

  if( !m_vsHoughVotes.isValid() ) {
    cerr << "  Error in ISM::getSupportingVotes(): "
         << "VotingSpace not properly initialized!" << endl;
    return vResult;
  }
  if( m_vsHoughVotes.numDims()!=2 ) {
    cerr << "  Error in ISM::getSupportingVotes(): "
         << "VotingSpace has wrong dimensionality!" << endl;
    return vResult;
  }

  FeatureVector fvWindowPos( 2 );
  fvWindowPos.setValue( 0, x );
  fvWindowPos.setValue( 1, y );

  FeatureVector fvWindowSize = getAdaptiveWinSize( fvWindowPos );
  return  getSupportingVotes( fvWindowPos, fvWindowSize );
}


list<HoughVote> ISM::getSupportingVotes( float x, float y, float s )
{
  list<HoughVote> vResult;

  if( !m_vsHoughVotes.isValid() ) {
    cerr << "  Error in ISM::getSupportingVotes(): "
         << "VotingSpace not properly initialized!" << endl;
    return vResult;
  }
  if( m_vsHoughVotes.numDims()!=3 ) {
    cerr << "  Error in ISM::getSupportingVotes(): "
         << "VotingSpace has wrong dimensionality!" << endl;
    return vResult;
  }

  FeatureVector fvWindowPos( 3 );
  fvWindowPos.setValue( 0, x );
  fvWindowPos.setValue( 1, y );
  fvWindowPos.setValue( 2, s );

  FeatureVector fvWindowSize = getAdaptiveWinSize( fvWindowPos );
  return  getSupportingVotes( fvWindowPos, fvWindowSize );
}


list<HoughVote> ISM::getSupportingVotes( FeatureVector fvWindowPos )
{
  list<HoughVote> vResult;

  if( !m_vsHoughVotes.isValid() ) {
    cerr << "  Error in ISM::getSupportingVotes(): "
         << "VotingSpace not properly initialized!" << endl;
    return vResult;
  }
  if( m_vsHoughVotes.numDims()!=fvWindowPos.numDims() ) {
    cerr << "  Error in ISM::getSupportingVotes(): "
         << "VotingSpace has wrong dimensionality!" << endl;
    return vResult;
  }

  FeatureVector fvWindowSize = getAdaptiveWinSize( fvWindowPos );
  return  getSupportingVotes( fvWindowPos, fvWindowSize );
}


list<HoughVote> ISM::getSupportingVotes( FeatureVector fvWindowPos,
                                           FeatureVector fvWindowSize )
{
  list<HoughVote> vResult;

  if( !m_vsHoughVotes.isValid() ) {
    cerr << "  Error in ISM::getSupportingVotes(): "
         << "VotingSpace not properly initialized!" << endl;
    return vResult;
  }
  if( m_vsHoughVotes.numDims()!=fvWindowPos.numDims() ) {
    cerr << "  Error in ISM::getSupportingVotes(): "
         << "VotingSpace has wrong dimensionality!" << endl;
    return vResult;
  }

  /* set the window size */
  m_vsHoughVotes.setWindowSize( fvWindowSize );
  
 /* set the Kernel type */
  int nKernelType = m_parReco.params()->m_nKernelType;
  switch( nKernelType ) {
  case KERNEL_HCUBE:
    m_vsHoughVotes.setKernelType( VotingSpace::KERNEL_HCUBE );
    break;

  case KERNEL_HSPHERE:
    m_vsHoughVotes.setKernelType( VotingSpace::KERNEL_HSPHERE );
    break;

  default:
    cerr << "Error in getSupportingVotes(): "
         << "Unknown kernel type (" << nKernelType << ")!" << endl;
  }

  vResult = m_vsHoughVotes.getSupportingVotes( fvWindowPos );
  
  return vResult;
}


/***********************************************************/
/*                   Initial Recognition                   */
/***********************************************************/
OpGrayImage ISM::drawVotePatches( /*const*/ vector<HoughVote>  &vVotes, 
                                  const PointVector           &vPoints,
                                  const vector<OpGrayImage>   &vClusterPatches,
                                  const FeatureCue            &parFeatures,
                                  int  nDrawStyle,
                                  bool bBackgroundZero,
                                  bool bVerbose )
{
	list<HoughVote> lVotes;
	for(int i=0;i<vVotes.size();i++)
		lVotes.push_back(vVotes[i]);
	drawVotePatches(lVotes,
			vPoints,
			vClusterPatches,
			parFeatures,
			nDrawStyle,
			bBackgroundZero,
			bVerbose);
}

OpGrayImage ISM::drawVotePatches( /*const*/ list<HoughVote>  &vVotes, 
                                  const PointVector           &vPoints,
                                  const vector<OpGrayImage>   &vClusterPatches,
                                  const FeatureCue            &parFeatures,
                                  int  nDrawStyle,
                                  bool bBackgroundZero,
                                  bool bVerbose )
  /*******************************************************************/
  /* Draw the support of a hypothesis, i.e. the backprojection from  */
  /* a set of votes to the patches they came from. Depending on the  */
  /* value of nDrawStyle, this method can be used to draw            */
  /*   a) the original support         (DRAW_SUPPORT)                */
  /*   b) a segmentation of the object (DRAW_SEGMENT)                */
  /*   c) the p(figure) prob. map      (DRAW_PFIG)                   */
  /*   d) the p(ground) prob. map      (DRAW_PGND)                   */
  /* In addition, the background can be set to a fixed value (useful */
  /* for drawing the original support) or to zero (useful when draw- */
  /* ing a segmentation) by setting the last option appropriately.   */
  /*******************************************************************/
{
  /******************************/
  /*   Prepare some variables   */
  /******************************/
  int nImgWidth   = (int) floor( m_vsHoughVotes.maxValue( 0 ) );
  int nImgHeight  = (int) floor( m_vsHoughVotes.maxValue( 1 ) );

  /******************************/
  /*   Prepare a result image   */
  /******************************/
  if( bVerbose )
    cout << "      Drawing vote patches for " << vVotes.size() << " votes..." 
         << endl;

  /* create an empty image */
  OpGrayImage imgResult      ( nImgWidth, nImgHeight );
  OpGrayImage imgValsPerPixel( nImgWidth, nImgHeight );
  

  /*****************************************/
  /*   Group votes from the same cluster   */
  /*****************************************/
  if( nDrawStyle==DRAW_SUPPORT ) {
    /* sort the votes */
    if( bVerbose )
      cout << "      Sorting the votes..." << endl;
//     stable_sort( vVotes.begin(), vVotes.end(), compHoughPoint() );
//     stable_sort( vVotes.begin(), vVotes.end(), compHoughCluster() );
    vVotes.sort( compHoughPoint() );
    vVotes.sort( compHoughCluster() );
    
    /* grouping votes from same cluster */
    if( bVerbose )
      cout << "      Compacting the votes... ";
    list<HoughVote> vReducedVotes;
    int nLastCluster = vVotes.front().getClusterId();
    int nLastPoint   = vVotes.front().getImgPointId();
    HoughVote hCurrent = vVotes.front();
//     for( int i=1; i<(int)vVotes.size(); i++ ) 
//       if( (vVotes[i].getClusterId() != nLastCluster) || 
//           (vVotes[i].getImgPointId()!= nLastPoint) ) {
    for( list<HoughVote>::iterator it=vVotes.begin()++; 
         it!=vVotes.end(); it++ )
      if( (it->getClusterId() != nLastCluster) || 
          (it->getImgPointId()!= nLastPoint) ) {
        vReducedVotes.push_back( hCurrent );
        
        nLastCluster = it->getClusterId();
        nLastPoint   = it->getImgPointId();
        hCurrent = *it;
        
      } else
        hCurrent.setValue( hCurrent.getValue() + it->getValue() );
    vReducedVotes.push_back( hCurrent );
    if( bVerbose )
      cout << " to " << vReducedVotes.size() << "." << endl;
    vVotes = vReducedVotes;
  } 


  /*************************************/
  /*   Copy the patches to the image   */
  /*************************************/
  float dScaleFactor = parFeatures.params()->m_dScaleFactor;
  int   nPatchSize   = parFeatures.params()->m_nPatchSize;
//   for(int i=0; i<(int)vVotes.size(); i++) {
  for( list<HoughVote>::iterator it=vVotes.begin(); it!=vVotes.end(); it++ ) {
      
    int nClusterId = it->getClusterId();
    int nOccId     = it->getOccNumber();
    int nOccMapIdx = m_vvOccurrences[nClusterId][nOccId].nOccMapIdx;
    int nPointId   = it->getImgPointId();
    int nDetectedSize = (int) floor(vPoints[nPointId].scale*
                                    dScaleFactor + 0.5);
    int imgsize     = 2*nPatchSize+1;
    int nTargetSize = 2*nDetectedSize+1; 

    /* prepare the information to draw: cluster or segm. map */
    OpGrayImage imgPatch;
    switch( nDrawStyle ) {
    case DRAW_SUPPORT:
      /* draw the cluster center */
      imgPatch = vClusterPatches[nClusterId];
      break;

    case DRAW_SEGMENT:
    case DRAW_PFIG:
    case DRAW_PGND:
      if( !m_vOccMaps.empty() ) {
        /* draw the occmap segmentation mask */
        if( nOccMapIdx<(int)m_vOccMaps.size() )
          imgPatch = m_vOccMaps[nOccMapIdx];
        else
          cerr << "  Invalid reference to OccMap (" << nOccMapIdx
               << "/" 
               << m_vOccMaps.size() << ") at ClusterId ("
               << nClusterId << ")!" << endl;  
      }
      break;
      
    default:
      cerr << "  Error in drawVotePatches(): "
           << "Invalid drawing style (" << nDrawStyle << ")!" << endl;
      return imgResult;
    }
    
    /* rescale the matched cluster to the detected size */
    if( vPoints[nPointId].l1 == vPoints[nPointId].l2 ) {
      /*-=-=-=-=-=-=-=-=-*/
      /* Circular region */
      /*-=-=-=-=-=-=-=-=-*/
      if( nTargetSize != imgsize )
        imgPatch = imgPatch.opRescaleToWidth( nTargetSize );

    } else {
        /*-=-=-=-=-=-=-=-=-=-*/
        /* Elliptical region */
        /*-=-=-=-=-=-=-=-=-=-*/
        imgPatch = createAffinePatch( imgPatch, vPoints[nPointId],
                                      parFeatures );
        nTargetSize = imgPatch.width();
      }
    
    /* add the rescaled patch to the result image */
    int posx = vPoints[nPointId].x;
    int posy = vPoints[nPointId].y;
    int minx = max( 0, posx - nDetectedSize );
    int miny = max( 0, posy - nDetectedSize );
    int maxx = min( imgResult.width(),  posx + nTargetSize );
    int maxy = min( imgResult.height(), posy + nTargetSize );
    int minxx= nTargetSize - min( nTargetSize, posx ); 
    int minyy= nTargetSize - min( nTargetSize, posy ); 
    int maxxx= min( nTargetSize, maxx-posx ); 
    int maxyy= min( nTargetSize, maxy-posy );
    float dConf = it->getValue();
    for( int y=miny, yy=minyy; (y<maxy) && (yy<maxyy); y++, yy++ )
      for( int x=minx, xx=minxx; (x<maxx) && (xx<maxxx); x++, xx++ ) {
        float dPatchValRaw = imgPatch(xx,yy).value();
        if( dPatchValRaw >= 0.0 ) {
          float dPatchVal    = dPatchValRaw/255.0;
          switch( nDrawStyle ) {
          case DRAW_SUPPORT:
          case DRAW_SEGMENT:
            imgResult(x,y)  = imgResult(x,y).value()  + dPatchValRaw;
            break;
            
          case DRAW_PFIG:
            imgResult(x,y) = imgResult(x,y).value() + dPatchVal*dConf;
            break;
            
          case DRAW_PGND:
            imgResult(x,y) = imgResult(x,y).value() + (1.0-dPatchVal)*dConf;
            break;
          }
          imgValsPerPixel(x,y) = imgValsPerPixel(x,y).value() + 1.0;
        }
      }
  }


  /* compute the average over all added patches */
  for( int y=0; y<imgResult.height(); y++ )
    for( int x=0; x<imgResult.width(); x++ ) {
      if( imgValsPerPixel(x,y).value() != 0.0 ) {
        if( (nDrawStyle==DRAW_SUPPORT) || (nDrawStyle==DRAW_SEGMENT) )
          imgResult(x,y) = ( imgResult(x,y).value() /
                             imgValsPerPixel(x,y).value() );
      } else 
        if( !bBackgroundZero )
          imgResult(x,y) = 200.0;
    }

  /* return the result image */
  return imgResult;
}


/***********************************************************/
/*                  Top-Down Segmentation                  */
/***********************************************************/


void ISM::drawSegmentation( const vector<HoughVote>    &vVotes,
                            const PointVector         &vPoints,
                            const FeatureCue          &parFeatures,
                            OpGrayImage &imgPFig, OpGrayImage &imgPGnd,
                            OpGrayImage &imgSeg,
                            bool bBackgroundZero,
                            float dRescaleBy,
                            bool bVerbose )
  /*******************************************************************/
  /* Draw the segmentation of a hypothesis. The method generates 3   */
  /* images: the p(figure) prob. map, the p(ground) prob. map, and   */
  /* the final segmentation of the object.                           */
  /* In addition, the background can be set to a fixed value or to   */
  /* zero by setting the bBackgroundZero option appropriately.       */
  /*******************************************************************/
{
  list<HoughVote> lVotes;
  for(int  i=0;i<vVotes.size();i++)
	lVotes.push_back(vVotes[i]);
  drawSegmentation( lVotes, vPoints, 
                    parFeatures.params()->m_dScaleFactor,
                    imgPFig, imgPGnd, imgSeg,
                    bBackgroundZero, dRescaleBy, bVerbose );
}
void ISM::drawSegmentation( const list<HoughVote>    &vVotes,
                            const PointVector         &vPoints,
                            const FeatureCue          &parFeatures,
                            OpGrayImage &imgPFig, OpGrayImage &imgPGnd,
                            OpGrayImage &imgSeg,
                            bool bBackgroundZero,
                            float dRescaleBy,
                            bool bVerbose )
  /*******************************************************************/
  /* Draw the segmentation of a hypothesis. The method generates 3   */
  /* images: the p(figure) prob. map, the p(ground) prob. map, and   */
  /* the final segmentation of the object.                           */
  /* In addition, the background can be set to a fixed value or to   */
  /* zero by setting the bBackgroundZero option appropriately.       */
  /*******************************************************************/
{
  drawSegmentation( vVotes, vPoints, 
                    parFeatures.params()->m_dScaleFactor,
                    imgPFig, imgPGnd, imgSeg,
                    bBackgroundZero, dRescaleBy, bVerbose );
}


void ISM::drawSegmentation( const list<HoughVote>     &vVotes,
                            const PointVector         &vPoints,
                            float dPatchScaleFactor,
                            OpGrayImage &imgPFig, OpGrayImage &imgPGnd,
                            OpGrayImage &imgSeg,
                            bool bBackgroundZero,
                            float dRescaleBy,
                            bool bVerbose )
  /*******************************************************************/
  /* Draw the segmentation of a hypothesis. The method generates 3   */
  /* images: the p(figure) prob. map, the p(ground) prob. map, and   */
  /* the final segmentation of the object.                           */
  /* In addition, the background can be set to a fixed value or to   */
  /* zero by setting the bBackgroundZero option appropriately.       */
  /*******************************************************************/
{
  if( bVerbose )
    cout << "      Drawing segmentation for " << vVotes.size() << " votes..." 
         << endl;

  /*****************************/
  /*   Prepare result images   */
  /*****************************/
  int w   = (int) floor( m_vsHoughVotes.maxValue( 0 ) );
  int h   = (int) floor( m_vsHoughVotes.maxValue( 1 ) );
  OpGrayImage imgTmp( w, h );
  OpGrayImage imgValsPerPixel = imgTmp;
  imgPFig = imgTmp;
  imgPGnd = imgTmp;
  imgSeg  = imgTmp;
  
  //int fastsize = w*h;
  //float fimgSegFast [fastsize];
  //float fimgPFigFast[fastsize];
  //float fimgPGndFast[fastsize];
  //int   iimgValsPerPixel[fastsize];
  //for( int i=0; i<fastsize; i++ ) {
  //  fimgSegFast[i] = fimgPFigFast[i] = fimgPGndFast[i] = 0.0;
  //  iimgValsPerPixel[i] = 0;
  //}

  /*************************************/
  /*   Copy the patches to the image   */
  /*************************************/
  //float dScaleFactor = parFeatures.params()->m_dScaleFactor * dRescaleBy;
  float dScaleFactor = dPatchScaleFactor * dRescaleBy;
  //int   nPatchSize   = parFeatures.params()->m_nPatchSize;  
//   for(int i=0; i<(int)vVotes.size(); i++)
  for( list<HoughVote>::const_iterator it=vVotes.begin(); 
       it!=vVotes.end(); it++ )
    /* only use votes for which the cue id matches */
    //    if( vVotes[i].getCueId()==m_nCue ) {
    if( it->getCueId()==m_nCue ) {

      int nClusterId = it->getClusterId();
      int nPointId   = it->getImgPointId();
      int nOccNumber = it->getOccNumber();
      int nDetectedSize = (int) floor(vPoints[nPointId].scale*
                                      dScaleFactor + 0.5);
      //int imgsize    = 2*nPatchSize+1;
      int nTargetSize= 2*nDetectedSize+1;
      
      /* retrieve the corresponding occ map */
      int nOccMapIdx = m_vvOccurrences[nClusterId][nOccNumber].nOccMapIdx;
      OpGrayImage imgPatch = m_vOccMaps[nOccMapIdx];
      int imgsize = imgPatch.width();
      
      /* rescale the occ map to the detected size */
      if( vPoints[nPointId].l1 == vPoints[nPointId].l2 ) {
        /*-=-=-=-=-=-=-=-=-*/
        /* Circular region */
        /*-=-=-=-=-=-=-=-=-*/
        if( nTargetSize != imgsize )
          imgPatch = imgPatch.opRescaleToWidth( nTargetSize );
        
      } else {
        /*-=-=-=-=-=-=-=-=-=-*/
        /* Elliptical region */
        /*-=-=-=-=-=-=-=-=-=-*/
        imgPatch = createAffinePatch( imgPatch, vPoints[nPointId],
                                      dPatchScaleFactor );
        nTargetSize = imgPatch.width();
      }
      
      /* add the rescaled cluster to the result image */
      int posx = vPoints[nPointId].x;
      int posy = vPoints[nPointId].y;
      int minx = max( 0, posx - nDetectedSize );
      int miny = max( 0, posy - nDetectedSize );
      int maxx = min( imgSeg.width(),  posx + nTargetSize );
      int maxy = min( imgSeg.height(), posy + nTargetSize );
      //int maxx = min( w, posx + nTargetSize );
      //int maxy = min( h, posy + nTargetSize );
      int minxx= nTargetSize - min( nTargetSize, posx ); 
      int minyy= nTargetSize - min( nTargetSize, posy ); 
      int maxxx= min( nTargetSize, maxx-posx ); 
      int maxyy= min( nTargetSize, maxy-posy );
      float dConf = it->getValue();
      for( int y=miny, yy=minyy; (y<maxy) && (yy<maxyy); y++, yy++ )
        for( int x=minx, xx=minxx; (x<maxx) && (xx<maxxx); x++, xx++ ) {
          float dPatchValRaw = imgPatch(xx,yy).value();
          if( dPatchValRaw >= 0.0 ) {
            float dPatchVal    = dPatchValRaw/255.0;
            imgSeg(x,y)  = imgSeg(x,y).value()  + dPatchValRaw;
            imgPFig(x,y) = imgPFig(x,y).value() + dPatchVal*dConf;
            imgPGnd(x,y) = imgPGnd(x,y).value() + (1.0-dPatchVal)*dConf;
            imgValsPerPixel(x,y) = imgValsPerPixel(x,y).value() + 1.0;
            //int idx = y*w+x;
            //fimgSegFast[idx] += dPatchValRaw;
            //fimgPFigFast[idx] += dPatchVal*dConf;
            //fimgPGndFast[idx] += (1.0-dPatchVal)*dConf;
            //iimgValsPerPixel[idx]++;
            
          }
        }
      
    }
  
  /* compute the average over all added patches */
  for( int y=0; y<imgSeg.height(); y++ )
    for( int x=0; x<imgSeg.width(); x++ )
      if( imgValsPerPixel(x,y).value() != 0.0 )
        imgSeg(x,y) = imgSeg(x,y).value() / imgValsPerPixel(x,y).value();
      else 
        if( !bBackgroundZero )
          imgSeg(x,y) = 100.0;  
  //for( int y=0; y<h; y++ )
  //  for( int x=0; x<w; x++ ) {
  //    int idx = y*w+x;
  //    imgPFig(x,y) = fimgPFigFast[idx];
  //    imgPGnd(x,y) = fimgPGndFast[idx];
  //    if( iimgValsPerPixel[idx]>0 )
  //      imgSeg(x,y) = fimgSegFast[idx] / (float)iimgValsPerPixel[idx];
  //    else 
  //      if( !bBackgroundZero )
  //        imgSeg(x,y) = 100.0;  
  //  }
}

void ISM::drawSegmentationOffset( const vector<HoughVote>   &vVotes,
                                  const PointVector       &vPoints,
                                  const FeatureCue        &parFeatures,
                                  int nOffX, int nOffY, float dHypoScale,
                                  OpGrayImage &imgPFig, 
                                  OpGrayImage &imgPGnd,
                                  OpGrayImage &imgSeg,
                                  bool bBackgroundZero,
                                  float dRescaleBy,
                                  int nSegWidth, int nSegHeight,
                                  bool bVerbose )
  /*******************************************************************/
  /* Draw the segmentation of a hypothesis. The method generates 3   */
  /* images: the p(figure) prob. map, the p(ground) prob. map, and   */
  /* the final segmentation of the object.                           */
  /* In addition, the background can be set to a fixed value or to   */
  /* zero by setting the last option appropriately.                  */
  /*******************************************************************/
{
  list<HoughVote> lVotes;
  convertv2l(vVotes, lVotes);
  drawSegmentationOffset( lVotes, vPoints, 
                          parFeatures.params()->m_dScaleFactor,
                          nOffX, nOffY, dHypoScale,
                          imgPFig, imgPGnd, imgSeg, 
                          bBackgroundZero, dRescaleBy, nSegWidth, nSegHeight,
                          bVerbose );
}


void ISM::drawSegmentationOffset( const list<HoughVote>   &vVotes,
                                  const PointVector       &vPoints,
                                  const FeatureCue        &parFeatures,
                                  int nOffX, int nOffY, float dHypoScale,
                                  OpGrayImage &imgPFig, 
                                  OpGrayImage &imgPGnd,
                                  OpGrayImage &imgSeg,
                                  bool bBackgroundZero,
                                  float dRescaleBy,
                                  int nSegWidth, int nSegHeight,
                                  bool bVerbose )
  /*******************************************************************/
  /* Draw the segmentation of a hypothesis. The method generates 3   */
  /* images: the p(figure) prob. map, the p(ground) prob. map, and   */
  /* the final segmentation of the object.                           */
  /* In addition, the background can be set to a fixed value or to   */
  /* zero by setting the last option appropriately.                  */
  /*******************************************************************/
{
  drawSegmentationOffset( vVotes, vPoints, 
                          parFeatures.params()->m_dScaleFactor,
                          nOffX, nOffY, dHypoScale,
                          imgPFig, imgPGnd, imgSeg, 
                          bBackgroundZero, dRescaleBy, nSegWidth, nSegHeight,
                          bVerbose );
}


void ISM::drawSegmentationOffset( const list<HoughVote>   &vVotes,
                                  const PointVector       &vPoints,
                                  float dPatchScaleFactor,
                                  int nOffX, int nOffY, float dHypoScale,
                                  OpGrayImage &imgPFig, 
                                  OpGrayImage &imgPGnd,
                                  OpGrayImage &imgSeg,
                                  bool bBackgroundZero,
                                  float dRescaleBy,
                                  int nSegWidth, int nSegHeight,
                                  bool bVerbose )
  /*******************************************************************/
  /* Draw the segmentation of a hypothesis. The method generates 3   */
  /* images: the p(figure) prob. map, the p(ground) prob. map, and   */
  /* the final segmentation of the object.                           */
  /* In addition, the background can be set to a fixed value or to   */
  /* zero by setting the last option appropriately.                  */
  /*******************************************************************/
{
  if( vVotes.size()==0 )
    return;

  /*******************************************/
  /*   Draw the corresponding segmentation   */
  /*******************************************/
  if( bVerbose )
    cout << "      Drawing segmentation for " << vVotes.size() << " votes..." 
         << endl;

  /****************************************/
  /*   Reduce the votes to unique cases   */
  /****************************************/
  list<HoughVote> vOldVotes( vVotes );
//   stable_sort( vOldVotes.begin(), vOldVotes.end(), compHoughPoint() );
//   stable_sort( vOldVotes.begin(), vOldVotes.end(), compHoughOccMap() );
  vOldVotes.sort( compHoughPoint() );
  vOldVotes.sort( compHoughOccMap() );
  vector<HoughVote> vNewVotes(1, vOldVotes.front() );
  unsigned nLastIdx = 0;
  int      nLastPoint = vNewVotes.front().getImgPointId();
  int      nLastOccMap= vNewVotes.front().getOccMapId();
//   for(unsigned i=1; i<vOldVotes.size(); i++ )
  for( list<HoughVote>::iterator it=vOldVotes.begin()++; 
       it!=vOldVotes.end(); it++ )
//     if( (vOldVotes[i].getImgPointId()==nLastPoint) && 
//         (vOldVotes[i].getOccMapId()==nLastOccMap) )
    if( (it->getImgPointId()==nLastPoint) && 
        (it->getOccMapId()==nLastOccMap) )
      vNewVotes.back().m_dValue += it->getValue();

    else {
      vNewVotes.push_back( *it );
      nLastIdx++;
      nLastPoint = it->getImgPointId();
      nLastOccMap= it->getOccMapId();
    }
  
  if( bVerbose )
    cout << "        reduced to " << vNewVotes.size() << " votes." << endl;


  /*****************************/
  /*   Prepare result images   */
  /*****************************/
  int w   = (int) floor( m_vsHoughVotes.maxValue( 0 ) );
  int h   = (int) floor( m_vsHoughVotes.maxValue( 1 ) );
  if( nSegWidth<0 ) 
    nSegWidth = w;
  if( nSegHeight<0 )
    nSegHeight = h;
  OpGrayImage imgTmp( nSegWidth, nSegHeight );
  OpGrayImage imgValsPerPixel = imgTmp;
  imgPFig = imgTmp;
  imgPGnd = imgTmp;
  imgSeg  = imgTmp;
  
  //int fastsize = w*h;
  //vector<float> fimgSegFast( fastsize );
  //vector<float> fimgPFigFast( fastsize );
  //vector<float> fimgPGndFast( fastsize );

  /*************************************/
  /*   Copy the patches to the image   */
  /*************************************/
  if( bVerbose )
    cout << "        PatchScale=" << dPatchScaleFactor 
         << ", RescaleBy=" << dRescaleBy 
         << ", HypoScale=" << dHypoScale << endl;
  float dScaleFactor = dPatchScaleFactor * dRescaleBy;
  //int   nPatchSize   = parFeatures.params()->m_nPatchSize;  
//   for(int i=0; i<(int)vNewVotes.size(); i++)
  for( vector<HoughVote>::iterator it=vNewVotes.begin(); 
       it!=vNewVotes.end(); it++ )
    /* only use votes for which the cue id matches */
//     if( vNewVotes[i].getCueId()==m_nCue ) {
    if( it->getCueId()==m_nCue ) {

      int nClusterId = it->getClusterId();
      int nPointId   = it->getImgPointId();
      int nOccNumber = it->getOccNumber();
      int nDetectedSize = (int) floor(vPoints[nPointId].scale*dHypoScale*
                                      dScaleFactor + 0.5);
      //int imgsize    = 2*nPatchSize+1;
      int nTargetSize= 2*nDetectedSize+1;
      
      /* retrieve the corresponding occ map */
      int nOccMapIdx = m_vvOccurrences[nClusterId][nOccNumber].nOccMapIdx;
      if( nOccMapIdx<0 || nOccMapIdx>=(int)m_vOccMaps.size() ) {
        cerr << "  WARNING in ISM::drawSegmentationOffset(): "
             << "OccMapIdx has invalid value (" << nOccMapIdx << ">" 
             << m_vOccMaps.size() << ")!" << endl;
        continue;
      }

      OpGrayImage imgPatch = m_vOccMaps[nOccMapIdx];
      int imgsize = imgPatch.width();
      
      /* rescale the occ map to the detected size */
      if( vPoints[nPointId].l1 == vPoints[nPointId].l2 ) {
        /*-=-=-=-=-=-=-=-=-*/
        /* Circular region */
        /*-=-=-=-=-=-=-=-=-*/
        if( nTargetSize != imgsize )
          imgPatch = imgPatch.opRescaleToWidth( nTargetSize );
        
      } else {
        /*-=-=-=-=-=-=-=-=-=-*/
        /* Elliptical region */
        /*-=-=-=-=-=-=-=-=-=-*/
        imgPatch = createAffinePatch( imgPatch, vPoints[nPointId], 
                                      dPatchScaleFactor );
        nTargetSize = imgPatch.width();
      }
      
      /* add the rescaled cluster to the result image */
      int posx = nOffX + (int)floor(vPoints[nPointId].x*dHypoScale + 0.5);
      int posy = nOffY + (int)floor(vPoints[nPointId].y*dHypoScale + 0.5);
      int minx = max( 0, posx - nDetectedSize );
      int miny = max( 0, posy - nDetectedSize );
      int maxx = min( imgSeg.width(),  posx + nTargetSize );
      int maxy = min( imgSeg.height(), posy + nTargetSize );
      int minxx= nTargetSize - min( nTargetSize, posx ); 
      int minyy= nTargetSize - min( nTargetSize, posy ); 
      int maxxx= min( nTargetSize, maxx-posx ); 
      int maxyy= min( nTargetSize, maxy-posy );
      float dConf = it->getValue();
      for( int y=miny, yy=minyy; (y<maxy) && (yy<maxyy); y++, yy++ )
        for( int x=minx, xx=minxx; (x<maxx) && (xx<maxxx); x++, xx++ ) {
          float dPatchValRaw = imgPatch(xx,yy).value();
          if( dPatchValRaw >= 0.0 ) {
            float dPatchVal    = dPatchValRaw/255.0;
            imgSeg(x,y)  = imgSeg(x,y).value()  + dPatchValRaw;
            imgPFig(x,y) = imgPFig(x,y).value() + dPatchVal*dConf;
            imgPGnd(x,y) = imgPGnd(x,y).value() + (1.0-dPatchVal)*dConf;
            imgValsPerPixel(x,y) = imgValsPerPixel(x,y).value() + 1.0;
          
//         int idx1 = yy*imgsize + xx;
//         int idx2 = y*fastsize + x;
//         float dPatchValRaw = imgPatch(xx,yy).value();
//         float dPatchVal    = dPatchValRaw/255.0;
//         fimgSegFast[idx2]  += dPatchValRaw;
//         fimgPFigFast[idx2] += dPatchVal*dConf;
//         fimgPGndFast[idx2] += (1.0-dPatchVal)*dConf;
//         imgValsPerPixel(x,y) = imgValsPerPixel(x,y).value() + 1.0;
        }
        }
      
    }
  
  /* compute the average over all added patches */
  float dMaxVal = 0.0;
  for( int y=0; y<imgSeg.height(); y++ )
    for( int x=0; x<imgSeg.width(); x++ ) {
      if( imgValsPerPixel(x,y).value() != 0.0 )
        imgSeg(x,y) = imgSeg(x,y).value() / imgValsPerPixel(x,y).value();
      else 
        if( !bBackgroundZero )
          imgSeg(x,y) = 100.0;  

      if( imgValsPerPixel(x,y).value() > dMaxVal )
        dMaxVal = imgValsPerPixel(x,y).value();
    }

  if( bVerbose )
    cout << "        (max pixel val=" << dMaxVal << ")." << endl
         << "      done." << endl;
}
Segmentation ISM::drawSegmentation( const list<HoughVote>     &vVotes,
                                    const PointVector         &vPoints,
                                    const FeatureCue          &parFeatures,
                                    bool bBackgroundZero,
                                    float dRescaleBy,
                                    bool bVerbose )
  /*******************************************************************/
  /* Draw the segmentation of a hypothesis. The method generates 3   */
  /* images: the p(figure) prob. map, the p(ground) prob. map, and   */
  /* the final segmentation of the object.                           */
  /* In addition, the background can be set to a fixed value or to   */
  /* zero by setting the bBackgroundZero option appropriately.       */
  /*******************************************************************/
{
  return drawSegmentation( vVotes, vPoints, 
                           parFeatures.params()->m_dScaleFactor,
                           bBackgroundZero, dRescaleBy, bVerbose );
}


Segmentation ISM::drawSegmentation( const list<HoughVote>     &vVotes,
                                    const PointVector         &vPoints,
                                    float dPatchScaleFactor,
                                    bool bBackgroundZero,
                                    float dRescaleBy,
                                    bool bVerbose )
  /*******************************************************************/
  /* Draw the segmentation of a hypothesis. The method generates 3   */
  /* images: the p(figure) prob. map, the p(ground) prob. map, and   */
  /* the final segmentation of the object.                           */
  /* In addition, the background can be set to a fixed value or to   */
  /* zero by setting the bBackgroundZero option appropriately.       */
  /*******************************************************************/
{
  OpGrayImage imgPFig;
  OpGrayImage imgPGnd;
  OpGrayImage imgSeg;
  drawSegmentation( vVotes, vPoints, dPatchScaleFactor,
                    imgPFig, imgPGnd, imgSeg,
                    bBackgroundZero, dRescaleBy, bVerbose );

  Segmentation segRes( imgPFig, imgPGnd, imgSeg );
  return segRes;
}

Segmentation ISM::drawSegmentationOffset( const vector<HoughVote> &vVotes,
                                          const PointVector       &vPoints,
                                          const FeatureCue        &parFeatures,
                                          int nOffX, int nOffY, 
                                          float dHypoScale,
                                          int nSegWidth, int nSegHeight,
                                          bool bBackgroundZero,
                                          float dRescaleBy,
                                          bool bVerbose )
  /*******************************************************************/
  /* Draw the segmentation of a hypothesis. The method generates 3   */
  /* images: the p(figure) prob. map, the p(ground) prob. map, and   */
  /* the final segmentation of the object.                           */
  /* In addition, the background can be set to a fixed value or to   */
  /* zero by setting the last option appropriately.                  */
  /*******************************************************************/
{
  list<HoughVote> lVotes;
  convertv2l(vVotes,lVotes);
  return drawSegmentationOffset( lVotes, vPoints, 
                                 parFeatures.params()->m_dScaleFactor,
                                 nOffX, nOffY, dHypoScale,
                                 nSegWidth, nSegHeight,
                                 bBackgroundZero, dRescaleBy, bVerbose );
}
Segmentation ISM::drawSegmentationOffset( const list<HoughVote> &vVotes,
                                          const PointVector       &vPoints,
                                          const FeatureCue        &parFeatures,
                                          int nOffX, int nOffY, 
                                          float dHypoScale,
                                          int nSegWidth, int nSegHeight,
                                          bool bBackgroundZero,
                                          float dRescaleBy,
                                          bool bVerbose )
  /*******************************************************************/
  /* Draw the segmentation of a hypothesis. The method generates 3   */
  /* images: the p(figure) prob. map, the p(ground) prob. map, and   */
  /* the final segmentation of the object.                           */
  /* In addition, the background can be set to a fixed value or to   */
  /* zero by setting the last option appropriately.                  */
  /*******************************************************************/
{
  return drawSegmentationOffset( vVotes, vPoints, 
                                 parFeatures.params()->m_dScaleFactor,
                                 nOffX, nOffY, dHypoScale,
                                 nSegWidth, nSegHeight,
                                 bBackgroundZero, dRescaleBy, bVerbose );
}


Segmentation ISM::drawSegmentationOffset( const list<HoughVote> &vVotes,
                                          const PointVector       &vPoints,
                                          float dPatchScaleFactor,
                                          int nOffX, int nOffY, 
                                          float dHypoScale,
                                          int nSegWidth, int nSegHeight,
                                          bool bBackgroundZero,
                                          float dRescaleBy,
                                          bool bVerbose )
  /*******************************************************************/
  /* Draw the segmentation of a hypothesis. The method generates 3   */
  /* images: the p(figure) prob. map, the p(ground) prob. map, and   */
  /* the final segmentation of the object.                           */
  /* In addition, the background can be set to a fixed value or to   */
  /* zero by setting the last option appropriately.                  */
  /*******************************************************************/
{
  OpGrayImage imgPFig;
  OpGrayImage imgPGnd;
  OpGrayImage imgSeg;
  drawSegmentationOffset( vVotes, vPoints, dPatchScaleFactor,
                          -nOffX, -nOffY, dHypoScale,
                          imgPFig, imgPGnd, imgSeg,
                          bBackgroundZero, dRescaleBy,
                          nSegWidth, nSegHeight, bVerbose );

  int nImgWidth   = (int) floor( m_vsHoughVotes.maxValue( 0 ) );
  int nImgHeight  = (int) floor( m_vsHoughVotes.maxValue( 1 ) );
  Segmentation segRes( imgPFig, imgPGnd, imgSeg, 
                       nOffX, nOffY, nImgWidth, nImgHeight );
  return segRes;
}


OpGrayImage ISM::createAffinePatch ( OpGrayImage img, InterestPoint pt,
                                     const FeatureCue &parFeatures )
/*******************************************************************/
/* Deform a patch so that it coincides with the given affine in-   */
/* terest region.                                                  */
/*******************************************************************/
{
  return createAffinePatch( img, pt, parFeatures.params()->m_dScaleFactor );
}


OpGrayImage ISM::createAffinePatch ( OpGrayImage img, InterestPoint pt,
                                     float dScaleFactor )
/*******************************************************************/
/* Deform a patch so that it coincides with the given affine in-   */
/* terest region.                                                  */
/*******************************************************************/
{
  //int   x      = (int)pt.x;
  //int   y      = (int)pt.y;
  float l1     = pt.l1;
  float l2     = pt.l2;
  float angle  = pt.angle;
  //float scfact = parFeatures.params()->m_dScaleFactor;
  float scfact = dScaleFactor;

  /*--------------------------------------*/
  /* Rescale the patch to elliptical size */
  /*--------------------------------------*/
  int   nNewWidth  = (int)( 2*floor(l1*scfact + 0.5) + 1);
  int   nNewHeight = (int)( 2*floor(l2*scfact + 0.5) + 1);
  OpGrayImage imgRegion = img.opRescaleToSize( nNewWidth, nNewHeight );

  /*--------------------------*/
  /* Copy into a bigger image */
  /*--------------------------*/
  float cosa = cos(angle)*scfact;
  float sina = sin(angle)*scfact;
  float rx = fabs(l1*cosa) + fabs(l2*sina);
  float ry = fabs(l1*sina) + fabs(l2*cosa);
  int   r  = (int)floor( max( rx, max( ry, max(l1,l2) ) ) + 0.5);

  int   nSize = 2*r+1;
  OpGrayImage imgBig( nSize, nSize );
  /* set pixels initially to -1 */
  imgBig.opThresholdBelow( 1.0, -1.0, -1.0 );
 
  /* copy the rescaled region into the bigger image */
  int   nOffX = (nSize - imgRegion.width())/2;
  int   nOffY = (nSize - imgRegion.height())/2;
  imgBig = imgBig.copy( imgRegion, nOffX, nOffY );
  
  /*----------------------------*/
  /* Rotate the region by alpha */
  /*----------------------------*/
  OpGrayImage imgRot = imgBig.rotate( angle, -1.0 ); // (new pixels set to -1)

  return imgRot;
}


/***********************************************************/
/*                     MDL Verification                    */
/***********************************************************/

vector<Hypothesis> ISM::doMDLSelection( HypoVec             &vHypos,
                                        vector<OpGrayImage> &vImgSegment,
                                        vector<OpGrayImage> &vImgPFig,
                                        vector<OpGrayImage> &vImgPGnd,
                                        vector<float>       &vSumPFig,
                                        vector<int>  &vRanks,
                                        bool bAlwaysAdapt,
                                        bool bVerbose )
  /*******************************************************************/
  /* Perform the MDL hypothesis selection step.                      */
  /* WARNING: The contents of the image vectors WILL BE CHANGED!!!   */
  /*******************************************************************/
{
  return doMDLSelection( vHypos, vImgSegment, vImgPFig, vImgPGnd, vSumPFig,
                         m_parReco.params()->m_dMinPFig, 
                         m_parReco.params()->m_dWeightPFig,
                         vRanks, bAlwaysAdapt, bVerbose );
}


vector<Hypothesis> ISM::doMDLSelection( HypoVec             &vHypos,
                                        vector<OpGrayImage> &vImgSegment,
                                        vector<OpGrayImage> &vImgPFig,
                                        vector<OpGrayImage> &vImgPGnd,
                                        vector<float>       &vSumPFig,
                                        float dThreshold,
                                        float dWeightPFig,
                                        vector<int>  &vRanks,
                                        bool bAlwaysAdapt,
                                        bool bVerbose )
  /*******************************************************************/
  /* Perform the MDL hypothesis selection step.                      */
  /* WARNING: The contents of the image vectors WILL BE CHANGED!!!   */
  /*******************************************************************/
{
  if( bVerbose ) {
    cout << "=======================================" << endl;
    cout << "MDL Hypothesis Selection:" << endl;
  }
 
  vector<Hypothesis> vResultHypos;
  int w   = (int) floor( m_vsHoughVotes.maxValue( 0 ) );
  int h   = (int) floor( m_vsHoughVotes.maxValue( 1 ) );
 
  bool  bNormScalePFig2    = m_parReco.params()->m_bNormScalePFig2;
  float dAdaptMinMDLScale  = m_parReco.params()->m_dAdaptMinMDLScale;
  float dAdaptMinMDLScale2 = dAdaptMinMDLScale*dAdaptMinMDLScale;

  /*----------------------------*/
  /* Compute the SumPFig values */
  /*----------------------------*/
  vector<float> vFigArea( (int)vHypos.size() );
  vector<float> vScore  ( (int)vHypos.size() );
  for( int k=0; k<(int)vHypos.size(); k++ ) {
    if( bVerbose ) {
      cout << "  " << setw(2) << k+1 << ". ";
      printHypothesis( vHypos[k] );
    }

    vFigArea[k] = vImgSegment[k].getSum()/255.0;
    vScore[k]   = dWeightPFig*vSumPFig[k] + (1.0-dWeightPFig)*vFigArea[k];

    if( bVerbose )
      cout << "          "
           << "FigArea="     << (int) vFigArea[k] 
           << ", Sum(pfig)=" << (int) vSumPFig[k]
           << ", Score="     << (int) vScore[k];

    if( bNormScalePFig2 ) {
      if( (vHypos[k].dScale > dAdaptMinMDLScale) || bAlwaysAdapt ) {
        float dScale2 = vHypos[k].dScale*vHypos[k].dScale;
        vSumPFig[k]  /= dScale2;
        vFigArea[k]  /= dScale2;
        
      } else {
        vSumPFig[k] /= dAdaptMinMDLScale2;
        vFigArea[k] /= dAdaptMinMDLScale2;
      }
      vScore[k]    = dWeightPFig*vSumPFig[k] + (1.0-dWeightPFig)*vFigArea[k];
      if( bVerbose )
        cout << ", (norm.: Score=" << vScore[k] << ")";
    }

    if( bVerbose )
      cout << endl;

    /* adapt the score by the area factor of the hypothesis */
    if( vHypos[k].dAreaFactor!=1.0 )
      vScore[k]  /= vHypos[k].dAreaFactor;
  }

  /* initialize the 'chosen' flags */
  vector<bool>  vChosen( (int)vHypos.size(), false );
  vRanks.clear();
  int nChosen = 0;
  bool bFinished = false;
  while( nChosen<(int)vHypos.size() && !bFinished ) {
    
    /*---------------------------------------*/
    /* Find the hypothesis with max. SumPFig */
    /*---------------------------------------*/
    float dMaxVal = 0.0;
    int   nMaxIdx = 0;
    for( int k=0; k<(int)vHypos.size(); k++ )
      if( !vChosen[k] ) {
        if( vScore[k] > dMaxVal ) {
          dMaxVal = vScore[k];
          nMaxIdx = k;
        }
      }
    
    if( dMaxVal < dThreshold )
      bFinished = true;
    
    else {
      /*------------------------*/
      /* Select this hypothesis */
      /*------------------------*/
      vChosen[nMaxIdx] = true;
      nChosen++;
      vRanks.push_back( nMaxIdx );

      vHypos[nMaxIdx].dScoreMDL = dMaxVal;
      vResultHypos.push_back( vHypos[nMaxIdx] );
      if( bVerbose )
        cout << "  Selected hypothesis " << nMaxIdx+1 << endl;
      
      /*---------------------------------*/
      /* Update the remaining hypotheses */
      /*---------------------------------*/
      for( int k=0; k<(int)vHypos.size(); k++ )
        if( !vChosen[k] ) {
          
          /* remove the overlapping area */
          for( int y=0; y<h; y++ )
            for( int x=0; x<w; x++ ) //{
              if( vImgPFig[nMaxIdx](x,y).value() > 
                  vImgPGnd[nMaxIdx](x,y).value() ) {
                vImgSegment[k](x,y) = 0.0;
                vImgPFig[k](x,y)    = 0.0;
              }
          vFigArea[k] = vImgSegment[k].getSum()/255.0;

          vSumPFig[k] = vImgPFig[k].getSum();
          //float dSum = 0.0;
          //for( int y=0; y<(int)vImgPFig[k].height(); y++ )
          //  for( int x=0; x<(int)vImgPFig[k].width(); x++ ) {
          //    float val = vImgPFig[k](x,y).value();
          //    if( val > vImgPGnd[k](x,y).value() )
          //      dSum += val;
          //  }
          //vSumPFig[k] = dSum;
          vScore[k] = dWeightPFig*vSumPFig[k] + (1.0-dWeightPFig)*vFigArea[k];
          
          if( bVerbose ) {
            cout << "  => " << setw(2) << k+1 << ". ";
            printHypothesis( vHypos[k] );
            cout << "             "
                 << "FigArea=" << vFigArea[k] 
                 << ", Sum(pfig)=" << vSumPFig[k]
                 << ", Score=" << (int) vScore[k];
          }

          /* normalize the scores by scale */
          if( bNormScalePFig2 ) {
            if( (vHypos[k].dScale > dAdaptMinMDLScale) || bAlwaysAdapt ) {
              float dScale2 = vHypos[k].dScale*vHypos[k].dScale;
              vSumPFig[k]  /= dScale2;
              vFigArea[k]  /= dScale2;
              
              } else {
                vSumPFig[k] /= (dAdaptMinMDLScale*dAdaptMinMDLScale);
                vFigArea[k] /= (dAdaptMinMDLScale*dAdaptMinMDLScale);
              }
              vScore[k] = ( dWeightPFig*vSumPFig[k] + 
                            (1.0-dWeightPFig)*vFigArea[k] );
              if( bVerbose )
                cout << ", (norm.: Score=" << (int) vScore[k] << ")";
          }
          
          if( bVerbose )
            cout << endl;

          /* adapt the score by the area factor of the hypothesis */
          if( vHypos[k].dAreaFactor!=1.0 )
            vScore[k]  /= vHypos[k].dAreaFactor;
        }
    }
  }
  if( bVerbose )
    cout << "=======================================" << endl;

  return vResultHypos;
}


vector<Hypothesis> ISM::doMDLSelection( HypoVec              &vHypos,
                                        vector<Segmentation> &vSegmentations,
                                        vector<int>  &vRanks,
                                        bool bAlwaysAdapt,
                                        bool bVerbose )
  /*******************************************************************/
  /* Perform the MDL hypothesis selection step.                      */
  /* (Optimized version using small segmentation images).            */
  /* WARNING: The contents of the image vectors WILL BE CHANGED!!!   */
  /*******************************************************************/
{
  return doMDLSelection( vHypos, vSegmentations,
                         m_parReco.params()->m_dMinPFig, 
                         m_parReco.params()->m_dWeightPFig,
                         vRanks, bAlwaysAdapt, bVerbose );
}


vector<Hypothesis> ISM::doMDLSelection( HypoVec              &vHypos,
                                        vector<Segmentation> &vSegmentations,
                                        float dThreshold,
                                        float dWeightPFig,
                                        vector<int>  &vRanks,
                                        bool bAlwaysAdapt,
                                        bool bVerbose )
  /*******************************************************************/
  /* Perform the MDL hypothesis selection step.                      */
  /* (Optimized version using small segmentation images).            */
  /* WARNING: The contents of the image vectors WILL BE CHANGED!!!   */
  /*******************************************************************/
{
  if( bVerbose ) {
    cout << "=======================================" << endl;
    cout << "MDL Hypothesis Selection:" << endl;
  }
 
  vector<Hypothesis> vResultHypos;
  //int w   = (int) floor( m_vsHoughVotes.maxValue( 0 ) );
  //int h   = (int) floor( m_vsHoughVotes.maxValue( 1 ) );
 
  //bool  bNormScalePFig2    = m_parReco.params()->m_bNormScalePFig2;
  //float dAdaptMinMDLScale  = m_parReco.params()->m_dAdaptMinMDLScale;
  //float dAdaptMinMDLScale2 = dAdaptMinMDLScale*dAdaptMinMDLScale;

  /*----------------------------*/
  /* Compute the SumPFig values */
  /*----------------------------*/
  vector<float> vSumPFig( (int)vHypos.size() );
  vector<float> vFigArea( (int)vHypos.size() );
  vector<float> vScore  ( (int)vHypos.size() );
  for( int k=0; k<(int)vHypos.size(); k++ ) {
    if( bVerbose ) {
      cout << "  " << setw(2) << k+1 << ". ";
      printHypothesis( vHypos[k] );
    }

    vSumPFig[k] = vSegmentations[k].getSumPFig();
    vFigArea[k] = vSegmentations[k].getSumSegArea();
    vScore[k]   = getMDLScore( vSumPFig[k], vFigArea[k], vHypos[k].dScale );
    
    /* adapt the score by the area factor of the hypothesis */
    if( vHypos[k].dAreaFactor!=1.0 )
      vScore[k]  /= vHypos[k].dAreaFactor;

    if( bVerbose ) {
      cout << "          "
           << "FigArea="     << (int) vFigArea[k] 
           << ", Sum(pfig)=" << (int) vSumPFig[k]
           << ", Score="     << (int) vScore[k];
      cout << endl;
    }
  }

  /* initialize the 'chosen' flags */
  vector<bool>  vChosen( (int)vHypos.size(), false );
  vRanks.clear();
  int nChosen = 0;
  bool bFinished = false;
  while( nChosen<(int)vHypos.size() && !bFinished ) {
    
    /*-------------------------------------*/
    /* Find the hypothesis with max. Score */
    /*-------------------------------------*/
    float dMaxVal = 0.0;
    int   nMaxIdx = 0;
    for( int k=0; k<(int)vHypos.size(); k++ )
      if( !vChosen[k] ) {
        if( vScore[k] > dMaxVal ) {
          dMaxVal = vScore[k];
          nMaxIdx = k;
        }
      }
    
    if( dMaxVal < dThreshold )
      bFinished = true;
    
    else {
      /*------------------------*/
      /* Select this hypothesis */
      /*------------------------*/
      vChosen[nMaxIdx] = true;
      nChosen++;
      vRanks.push_back( nMaxIdx );

      vHypos[nMaxIdx].dScoreMDL = dMaxVal;
      vResultHypos.push_back( vHypos[nMaxIdx] );
      if( bVerbose )
        cout << "  Selected hypothesis " << nMaxIdx+1 << endl;
      
      /*---------------------------------*/
      /* Update the remaining hypotheses */
      /*---------------------------------*/
      OpGrayImage imgChPFig = vSegmentations[nMaxIdx].getImgPFig();
      OpGrayImage imgChPGnd = vSegmentations[nMaxIdx].getImgPGnd();
      int nChOffX           = vSegmentations[nMaxIdx].getOffsetX();
      int nChOffY           = vSegmentations[nMaxIdx].getOffsetY();
      int nChMaxX           = nChOffX + imgChPFig.width()-1;
      int nChMaxY           = nChOffY + imgChPFig.height()-1;
      for( int k=0; k<(int)vHypos.size(); k++ )
        if( !vChosen[k] ) {
          
          /* check if there is an overlap with this segmentation */
          OpGrayImage imgOthPFig = vSegmentations[k].getImgPFig();
          OpGrayImage imgOthSeg  = vSegmentations[k].getImgSeg();
          int nOthOffX           = vSegmentations[k].getOffsetX();
          int nOthOffY           = vSegmentations[k].getOffsetY();
          int nOthMaxX           = nOthOffX + imgOthPFig.width()-1;
          int nOthMaxY           = nOthOffY + imgOthPFig.height()-1;
          int minx, miny, maxx, maxy;
          if( checkOverlap( nChOffX,  nChOffY,  nChMaxX,  nChMaxY,
                            nOthOffX, nOthOffY, nOthMaxX, nOthMaxY,
                            minx, miny, maxx, maxy ) ) {

            /* remove the overlapping area */
            int minChX  = minx - nChOffX;
            int minChY  = miny - nChOffY;
            int maxChX  = maxx - nChOffX;
            int maxChY  = maxy - nChOffY;
            int minOthX = minx - nOthOffX;
            int minOthY = miny - nOthOffY;
            int maxOthX = maxx - nOthOffX;
            int maxOthY = maxy - nOthOffY;
            for( int y=minChY, yy=minOthY; y<maxChY && yy<maxOthY; y++, yy++ )
              for( int x=minChX, xx=minOthX; x<maxChX && xx<maxOthX; x++,xx++ )
                if( imgChPFig(x,y).value() > imgChPGnd(x,y).value() ) {
                  imgOthPFig(xx,yy) = 0.0;
                  imgOthSeg(xx,yy)  = 0.0;
                }
            vSegmentations[k].updateImgPFig( imgOthPFig );
            vSegmentations[k].updateImgSeg ( imgOthSeg  );

            /* update the scores */
            vFigArea[k] = vSegmentations[k].getSumSegArea();
            vSumPFig[k] = vSegmentations[k].getSumPFig();
            vScore[k]   = getMDLScore( vSumPFig[k], vFigArea[k], 
                                       vHypos[k].dScale );

            /* adapt the score by the area factor of the hypothesis */
            if( vHypos[k].dAreaFactor!=1.0 )
              vScore[k]  /= vHypos[k].dAreaFactor;
          }

          if( bVerbose ) {
            cout << "  => " << setw(2) << k+1 << ". ";
            printHypothesis( vHypos[k] );
            cout << "             "
                 << "FigArea=" << vFigArea[k] 
                 << ", Sum(pfig)=" << vSumPFig[k]
                 << ", Score=" << (int) vScore[k];
          }
          
          if( bVerbose )
            cout << endl;
        }
    }
  }
  if( bVerbose )
    cout << "=======================================" << endl;

  return vResultHypos;
}


vector<Hypothesis> ISM::doMDLSelExact( HypoVec             &vHypos,
                                       vector<OpGrayImage> &vImgSegment,
                                       vector<OpGrayImage> &vImgPFig,
                                       vector<OpGrayImage> &vImgPGnd,
                                       vector<float>       &vSumPFig,
                                       float dThreshold,
                                       vector<int>  &vRanks,
                                       bool bAlwaysAdapt,
                                       bool bVerbose )
  /*******************************************************************/
  /* Perform the MDL hypothesis selection step.                      */
  /* WARNING: The contents of the image vectors WILL BE CHANGED!!!   */
  /*******************************************************************/
{
  if( bVerbose ) {
    cout << "=======================================" << endl;
    cout << "MDL Hypothesis Selection:" << endl;
  }
 
  vector<Hypothesis> vResultHypos;
  int w   = (int) floor( m_vsHoughVotes.maxValue( 0 ) );
  int h   = (int) floor( m_vsHoughVotes.maxValue( 1 ) );
 
  bool  bNormScalePFig2    = m_parReco.params()->m_bNormScalePFig2;
  float dWeightPFig        = m_parReco.params()->m_dWeightPFig;
  float dAdaptMinMDLScale  = m_parReco.params()->m_dAdaptMinMDLScale;
  float dAdaptMinMDLScale2 = dAdaptMinMDLScale*dAdaptMinMDLScale;
 
  /*----------------------------*/
  /* Compute the SumPFig values */
  /*----------------------------*/
  vector<float> vFigArea( vHypos.size() );
  vector<float> vScore  ( (int)vHypos.size() );
  for( int k=0; k<(int)vHypos.size(); k++ ) {
    if( bVerbose ) {
      cout << "  " << setw(2) << k+1 << ". ";
      printHypothesis( vHypos[k] );
    }
    
    vFigArea[k] = vImgSegment[k].getSum()/255.0;
    vScore[k]   = dWeightPFig*vSumPFig[k] + (1.0-dWeightPFig)*vFigArea[k];

    if( bVerbose ) {
      cout << "          "
           << "FigArea="     << (int) vFigArea[k] 
           << ", Sum(pfig)=" << (int) vSumPFig[k]
           << ", Score="     << (int) vScore[k];
    }
    
    if( bNormScalePFig2 ) {
      if( (vHypos[k].dScale > dAdaptMinMDLScale) || bAlwaysAdapt ) {
        float dScale2 = vHypos[k].dScale*vHypos[k].dScale;
        vSumPFig[k]  /= dScale2;
        vFigArea[k]  /= dScale2;

        } else {
          vSumPFig[k] /= dAdaptMinMDLScale2;
          vFigArea[k] /= dAdaptMinMDLScale2;
        }
      vScore[k] = dWeightPFig*vSumPFig[k] + (1.0-dWeightPFig)*vFigArea[k];
      if( bVerbose )
        cout << ", (norm.: Score=" << vScore[k] << ")";
    }

    if( bVerbose )
      cout << endl;

    /* adapt the score by the area factor of the hypothesis */
    if( vHypos[k].dAreaFactor!=1.0 )
      vScore[k]  /= vHypos[k].dAreaFactor;
  }

  /* initialize the maximal image */
  OpGrayImage imgMaxVal( w, h );
  OpGrayImage imgMaxIdx( w, h );

  /* initialize the 'chosen' flags */
  vector<bool>  vChosen  ( (int)vHypos.size(), false );
  vector<bool>  vRejected( (int)vHypos.size(), false );
  vRanks.clear();
  int nChosen = 0;
  int nRejected = 0;
  bool bFinished = false;
  while( (nChosen+nRejected)<(int)vHypos.size() && !bFinished ) {
    
    /*---------------------------------------*/
    /* Find the hypothesis with max. SumPFig */
    /*---------------------------------------*/
    float dMaxVal = 0.0;
    int   nMaxIdx = 0;
    for( int k=0; k<(int)vHypos.size(); k++ )
      if( !vChosen[k] && !vRejected[k] ) {
        if( vScore[k] > dMaxVal ) {
          dMaxVal = vScore[k];
          nMaxIdx = k;
        }
      }
    
    if( dMaxVal < dThreshold )
      bFinished = true;
    
    else {
      /*----------------------*/
      /* Test this hypothesis */
      /*----------------------*/
      float dPFigContrib = 0.0;
      float dAreaContrib = 0.0;
      for( int y=0; y<h; y++ )
        for( int x=0; x<w; x++ ) {
          float newval = vImgPFig[nMaxIdx](x,y).value();
          if( newval > vImgPGnd[nMaxIdx](x,y).value() )
            if( newval > imgMaxVal(x,y).value() ) {
              dPFigContrib += newval - imgMaxVal(x,y).value();
              dAreaContrib += 1.0;
            }
        }
      float dSumContrib = ( dWeightPFig*dPFigContrib + 
                            (1.0-dWeightPFig)*dAreaContrib );
          
      /* normalize contribution with scale */
      float dSumContribNorm = dSumContrib;
      if( bNormScalePFig2 ) {
        if( (vHypos[nMaxIdx].dScale > dAdaptMinMDLScale) || bAlwaysAdapt ) {
          dSumContribNorm /= (vHypos[nMaxIdx].dScale*vHypos[nMaxIdx].dScale);
          
        } else {
          dSumContribNorm /= dAdaptMinMDLScale2;
        }
      }
      
      bool bSelectHypo = false;
      if( dSumContribNorm >= dThreshold ) {
        /*------------------------*/
        /* Select this hypothesis */
        /*------------------------*/
        vChosen[nMaxIdx] = true;
        nChosen++;
        vRanks.push_back( nMaxIdx );
        bSelectHypo = true;
        
        vHypos[nMaxIdx].dScoreMDL = dMaxVal;
        if( bVerbose )
          cout << "  Selected hypothesis " << nMaxIdx+1;

      } else {
        /*------------------------*/
        /* Reject this hypothesis */
        /*------------------------*/
        vRejected[nMaxIdx] = true;
        nRejected++;
        if( bVerbose )
          cout << "  Rejected hypothesis " << nMaxIdx+1;
      }
      if( bVerbose )
        cout << " (contrib=" << dSumContrib << ", norm=" << dSumContribNorm 
             << ")" << endl;
      
      if( bSelectHypo ) {
        /*---------------------------------*/
        /* Update the maximal pfig entries */
        /*---------------------------------*/
        for( int y=0; y<h; y++ )
          for( int x=0; x<w; x++ ) {
            float newval = vImgPFig[nMaxIdx](x,y).value();
            if( newval > vImgPGnd[nMaxIdx](x,y).value() )
              if( newval > imgMaxVal(x,y).value() ) {
                /* remove the old entry */
                int nOldIdx = (int)imgMaxIdx(x,y).value();
                if( nOldIdx > 0 ) {
                  vImgPFig[nOldIdx-1](x,y)    = 0.0;
                  vImgSegment[nOldIdx-1](x,y) = 0.0;
                }
                
                /* set the new entry */
                imgMaxVal(x,y) = newval;
                imgMaxIdx(x,y) = (float)nMaxIdx+1.0;
              }
          }
        
        /*---------------------------------*/
        /* Update the remaining hypotheses */
        /*---------------------------------*/
        for( int k=0; k<(int)vHypos.size(); k++ ) {
          if( vChosen[k] ) {
            /* update a chosen hypothesis */
            
            /* shouldn't have to do anything */
            
          } else {
            /* update a candidate hypothesis */
            
            /* remove the overlapping area */
            /* !!!NEW: keep the maximal pfig values!!! */
            if( k != nMaxIdx )
              for( int y=0; y<h; y++ )
                for( int x=0; x<w; x++ ) //{
                  if( vImgPFig[nMaxIdx](x,y).value() > 
                      vImgPGnd[nMaxIdx](x,y).value() ) {
                    if( vImgPFig[nMaxIdx](x,y).value() > 
                        vImgPFig[k](x,y).value() ) {
                      vImgSegment[k](x,y) = 0.0;
                      vImgPFig[k](x,y)    = 0.0;
                    }
                  }
          }
          
          vFigArea[k] = vImgSegment[k].getSum()/255.0;
          vSumPFig[k] = vImgPFig[k].getSum();
          vScore[k] = dWeightPFig*vSumPFig[k] + (1.0-dWeightPFig)*vFigArea[k];
          
          if( bVerbose ) {
            cout << "  => " << setw(2) << k+1 << ". ";
            if( vChosen[k] )
              cout << "X";
            else if(vRejected[k] )
              cout << "O";
            else
              cout << " ";
            printHypothesis( vHypos[k] );
            cout << "             "
                 << "FigArea="     << vFigArea[k] 
                 << ", Sum(pfig)=" << vSumPFig[k]
                 << ", Score="     << (int) vScore[k];
          }
          
          /* normalize the scores by scale */
          if( bNormScalePFig2 ) {
            if( (vHypos[k].dScale > dAdaptMinMDLScale) || bAlwaysAdapt ) {
              float dScale2 = vHypos[k].dScale*vHypos[k].dScale;
              vSumPFig[k]  /= dScale2;
              vFigArea[k]  /= dScale2;
              
            } else {
              vSumPFig[k] /= (dAdaptMinMDLScale*dAdaptMinMDLScale);
              vFigArea[k] /= (dAdaptMinMDLScale*dAdaptMinMDLScale);
            }
            vScore[k] = ( dWeightPFig*vSumPFig[k] + 
                          (1.0-dWeightPFig)*vFigArea[k] );
            if( bVerbose )
              cout << ", (norm.: Score=" << (int) vScore[k] << ")";
          }
          
          /* adapt the score by the area factor of the hypothesis */
          if( vHypos[k].dAreaFactor!=1.0 )
            vScore[k]  /= vHypos[k].dAreaFactor;
          
          vHypos[k].dScoreMDL = vScore[k];
          
          if( bVerbose )
            cout << endl;
        } /* end for */
      } /* end if(bSelectHypo) */
    } 
  }
  if( bVerbose )
    cout << "=======================================" << endl;

  /* collect the chosen hypotheses */
  for( int i=0; i<nChosen; i++ )
    vResultHypos.push_back( vHypos[vRanks[i]] );

  return vResultHypos;
}


float ISM::getMDLScore( float dSumPFig, float dFigArea, float dScale )
{
  bool  bNormScalePFig2    = m_parReco.params()->m_bNormScalePFig2;
  float dWeightPFig        = m_parReco.params()->m_dWeightPFig;
  float dAdaptMinMDLScale  = m_parReco.params()->m_dAdaptMinMDLScale;
  //float dAdaptMinMDLScale2 = dAdaptMinMDLScale*dAdaptMinMDLScale;

  float dScore   = dWeightPFig*dSumPFig + (1.0-dWeightPFig)*dFigArea;
  
//   if( bNormScalePFig2 )
//     if( dScale > dAdaptMinMDLScale )
//       dScore /= (dScale*dScale);
//     else
//       dScore /= dAdaptMinMDLScale2;
      
  if( bNormScalePFig2 )
    if( dScale > dAdaptMinMDLScale ) {
      float dNormVal = 1.0+(dScale-dAdaptMinMDLScale);
      dScore /= (dNormVal*dNormVal);
    }
 
  return dScore;
}


bool ISM::checkOverlap ( int  Px1, int  Py1, int  Px2, int  Py2,
                         int  Qx1, int  Qy1, int  Qx2, int  Qy2,
                         int &Rx1, int &Ry1, int &Rx2, int &Ry2 )
  /*******************************************************************/
  /* Check the overlap between the boxes P and Q. If the boxes over- */
  /* lap, the function returns true, and the overlapping area is     */
  /* given by R. Else, the function returns false.                   */
  /*******************************************************************/
{
  Rx1 = max( Px1, Qx1 );
  Ry1 = max( Py1, Qy1 );
  Rx2 = min( Px2, Qx2 );
  Ry2 = min( Py2, Qy2 );
  if( (Rx2>=Rx1) && (Ry2>=Ry1) )
    return true;
  else
    return false;
}


/***********************************************************/
/*                    Service Functions                    */
/***********************************************************/

FeatureVector ISM::getAdaptiveWinSize( FeatureVector fvWindowPos )
{
  float dMSMESizeX = m_parReco.params()->m_dMSMESizeX;
  float dMSMESizeY = m_parReco.params()->m_dMSMESizeY;
  float dMSMESizeS = m_parReco.params()->m_dMSMESizeS;
  float dAdaptMinScale = m_parReco.params()->m_dAdaptMinScale;
  bool  bAdaptiveScale = m_parReco.params()->m_bAdaptiveScale;

  FeatureVector fvWindowSize( 3 );
  if( bAdaptiveScale ) {
    if( fvWindowPos.at(2) > dAdaptMinScale ) {
      fvWindowSize.setValue( 0, dMSMESizeX*fvWindowPos.at(2) );
      fvWindowSize.setValue( 1, dMSMESizeY*fvWindowPos.at(2) );
      fvWindowSize.setValue( 2, dMSMESizeS*fvWindowPos.at(2) );
    } else {
      fvWindowSize.setValue( 0, dMSMESizeX*dAdaptMinScale );
      fvWindowSize.setValue( 1, dMSMESizeY*dAdaptMinScale );
      fvWindowSize.setValue( 2, dMSMESizeS*dAdaptMinScale );
    }
  } else {
    fvWindowSize.setValue( 0, dMSMESizeX );
    fvWindowSize.setValue( 1, dMSMESizeY );
    fvWindowSize.setValue( 2, dMSMESizeS );
  }

  return fvWindowSize;
}


void ISM::writeResultsToDiskUIUC( ofstream &ofile, int nImgNumber,
                                  const HypoVec &vHypos )
  /*******************************************************************/
  /* Write the results to disk in the Agarwal & Roth format.         */
  /*******************************************************************/
{
  if( ofile != 0 ) {
    ofile << ' ' << nImgNumber << ":";
    
    for( int i=0; i<(int)vHypos.size(); i++ )
      ofile << " (" << vHypos[i].nBoxY1 << "," << vHypos[i].nBoxX1 << ")";
    ofile << endl;
  }
}


void ISM::writeResultsToDiskScore( ofstream &ofile, int nImgNumber,
                                   const HypoVec &vHypos )
  /*******************************************************************/
  /* Write the results to disk including the exact value of the      */
  /* hypotheses scores.                                              */
  /*******************************************************************/
{
  if( ofile != 0 ) {
    ofile << nImgNumber << endl;

    ofile << (int)vHypos.size() << endl;
   
    for( int i=0; i<(int)vHypos.size(); i++ )
      ofile << vHypos[i].x << "  " << vHypos[i].y << "  " 
            << vHypos[i].nBoxX1 << "  " << vHypos[i].nBoxY1 << "  "
            << vHypos[i].nBoxWidth << "  " << vHypos[i].nBoxHeight << "  "
            << vHypos[i].dScale << "  " << vHypos[i].dScore << endl;
  }
}


