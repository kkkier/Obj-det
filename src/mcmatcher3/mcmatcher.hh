/*********************************************************************/
/*                                                                   */
/* FILE         mcmatcher.hh                                         */
/* AUTHORS      Bastian Leibe                                        */
/* EMAIL        leibe@vision.ee.ethz.ch                              */
/*                                                                   */
/* CONTENT      Interleaved Object Categorization and Segmentation   */
/*              with an Implicit Shape Model.                        */
/*              The program performs simultaneous recognition and    */
/*              segmentation of canonical views of categorical ob-   */
/*              jects, such as sideviews of cars or cows. Prior to   */
/*              recognition, a codebook of local appearance must be  */
/*              generated by the 'clusterer' program. This version   */
/*              of the code currently just handles objects at a      */
/*              single scale.                                        */
/*                                                                   */
/*              Extended version for multi-cue recognition.          */
/*                                                                   */
/*              An explanation of the algorithm can be found in the  */
/*              following papers:                                    */
/*                                                                   */
/*              Bastian Leibe and Bernt Schiele,                     */
/*              Interleaved Object Categorization and Segmentation.  */
/*              In Proc. British Machine Vision Conference (BMVC'03) */
/*              Norwich, GB, Sept. 9-11, 2003.                       */
/*                                                                   */
/*              Bastian Leibe and Bernt Schiele,                     */
/*              Combined Object Categorization and Segmentation with */
/*              an Implicit Shape Model.                             */
/*              submitted to ECCV'04 Workshop on Statistical Lear-   */
/*              ning in Computer Vision, Prague, May 2004.           */
/*                                                                   */
/* BEGIN        Tue Nov 05 2002                                      */
/* LAST CHANGE  Tue Oct 11 2005                                      */
/*                                                                   */
/*********************************************************************/

#ifndef MCMATCHER_HH
#define MCMATCHER_HH

using namespace std;

/****************/
/*   Includes   */
/****************/
#include <qwidget.h>
#include <qstring.h>
#include <qimage.h>
#include <qtable.h>
#include <qpoint.h>
#include <qcolor.h>

#include <qtresizeimg.hh>
#include <qtclusterview.hh>
#include <qticonview.hh>
#include <opgrayimage.hh>
#include <opinterestimage.hh>
#include <featurevector.hh>
#include <nnsearch.hh>
#include <histogram.hh>
#include <visualhistogram.hh>
#include <cluster.hh>
#include <clstep.hh>
#include <pyramidscalespace.hh>
//#include "../libIDL2/imgdescrlist.hh" // explicitly use libIDL2!
#include <imgdescrlist.hh> // explicitly use libIDL!
#include <votingspace.hh>
#include <chamfermatching.h>
#include <occurrences.hh>
#include <codebook.hh>
#include <ism.hh>
#include <featuregui.hh>
#include <featurecue.hh>
#include <recogui.hh>
#include <recoparams.hh>
#include <matchinggui.hh>
#include <matchingparams.hh>
#include <matchinginfo.hh>
#include <cuewidget.hh>
#include <detector.hh>
#include <detectorwidget.hh>
#include <calibration.hh>

#include "verigui.hh"
#include "veriparams.hh"
#include "matwriter.hh"

//#include "parts.hh"

/*******************/
/*   Definitions   */
/*******************/
const string STR_NAME         = "Multi-cue ISM";
const string STR_VERSION      = "1.4.1";
const string STR_DATE         = "20.02.2008";
const string STR_COPYRIGHT    = "Copyright 2001-2008 Bastian Leibe";
const string STR_LICENSE      = 
"This code is provided exclusively for non-commercial research use.\n\
Commercialization (of any kind) is strictly prohibited. The code and\n\
binaries are under copyright protection. If you are interested in \n\
commercialization or more optimized versions, please contact us at\n\
leibe@vision.ee.ethz.ch.";
const string STR_DISCLAIMER   = "THIS CODE IS PROVIDED 'AS IS' AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. Use at your own risk.";

const float FACTOR_SIM_EDGESIFT = 800.0;  

const string DIR_HOME         = "/home/bleibe/";
const string DIR_IMAGES       = DIR_HOME+"images";
const string DIR_CODEBOOKS    = DIR_HOME+"codebooks";
const string DIR_RESULTS      = DIR_HOME+"results";

const string DIR_SILHOUETTES  = DIR_HOME+"images/training-data/pedestrians/silhouettes/silhouettes-210imgs-both-150";


const bool  OVERDRAW_IMG   = true; //draw interest points over source image

const float EPS_PFIG          = 0.0001;

const int SIZE_VOTINGBINS     = 10;

const int GP_CURRENT  = 0;
const int GP_PREVIOUS = 1;

//const float DEF_WORLD_SCALE = 0.049603;
//const float DEF_IMAGE_SCALE = 0.5;

#define USE_MATWRITER USE_MATWRITER


struct compPairDecr
{
  bool operator()( const pair<float,int> &x, const pair<float,int> &y )
  { return (x.first > y.first); }
};

/*--------*/
/* Result */
/*--------*/
typedef struct _Result
{
public:
  int   nRank;
  float dDistX;
  float dDistY;
  float dDist;
  float dCover;
  float dOverlap;
} Result;


class ISMReco: public QWidget
{
  Q_OBJECT
public:
  ISMReco( QWidget *parent=0, const char *name=0 );
  
public slots:
  /**************************/
  /*   Interface Handlers   */
  /**************************/
  void slotSetMapThresh           ( const QString &text );
  void slotSetImgScale            ( const QString &text );
  void slotSetWorldScale          ( const QString &text );
  void slotSetMaxOverlap          ( const QString &text );
  void slotSetMinPFig             ( const QString &text );
  void slotSetWeightPFig          ( const QString &text );
  //  void slotSetMinPFigRefined      ( const QString &text );
  void slotUpdateImgScale();
  void slotUpdateWorldScale();
  void slotUpdateMapThresh();
  void slotUpdateMaxOverlap();
  void slotUpdateMinPFig();
  void slotUpdateWeightPFig();
  //  void slotUpdateMinPFigRefined();

//   void slotSelectCombiMethod      ( int   state );
  void slotSelectGPFrame          ( int   state );

  void slotSetGrayConvOnOff       ( int   state );
  void slotSetGammaNormOnOff      ( int   state );
//   void slotSetBothDirOnOff        ( int   state );
  void slotSetUsePatchesOnOff     ( int   state );
  void slotSetDrawMapsOnOff       ( int   state );
  void slotSetDrawConfOnOff       ( int   state );
  void slotSetShowTxtStepsOnOff   ( int   state );
  void slotSetShowTxtDetailsOnOff ( int   state );
  void slotSetShowTxtVotingOnOff  ( int   state );
  void slotSetShowTxtMDLOnOff     ( int   state );
  void slotSetShowTimingsOnOff    ( int   state );
  void slotSetShowIntPtsOnOff     ( int   state );
  //void slotSetDrawMatchedPsOnOff  ( int   state );
  void slotSetFigureOnOff         ( int   state );
  void slotSetDrawTightBBOnOff    ( int   state );
  void slotSetEvalUniqueOnOff     ( int   state );
  void slotSetDisplayVSOnOff      ( int   state );
  void slotSetDisplaySupportOnOff ( int   state );
  void slotSetDisplaySegmentOnOff ( int   state );
  void slotSetDisplayMultiCueOnOff( int   state );
  //void slotSetRefineHypoOnOff     ( int   state );
  void slotSetWriteResultsOnOff   ( int   state );
  void slotSetWriteSegsOnOff      ( int   state );
  void slotSetDoMDLOnOff          ( int   state );
  void slotSetRejectOverlapOnOff  ( int   state );
  void slotSetRejectPFigOnOff     ( int   state );
  //void slotSetResampleHyposOnOff  ( int   state );
  //void slotSetWriteDetectOnOff    ( int   state );
  //void slotSetDrawRejectedOnOff   ( int   state );

  /*************************/
  /*   Regular Functions   */
  /*************************/
  void setShowGUI( bool bShowGUI ) { m_bShowGUI = bShowGUI; }

  /*----------------*/
  /* Loading Images */
  /*----------------*/
  void loadImage    (); 
  void loadImage    ( QString qsFileName );

  void drawGroundPlane();
  void drawDistHLine( float x1, float x2, float d, float h, 
                      QColor col=Qt::cyan );
  void drawDistVLine( float x, float d1, float d2, float h, 
                      QColor col=Qt::cyan );
  void drawDistZLine( float x, float d, float h1, float h2,
                      QColor col=Qt::cyan );
  void showResultImg( int dummy1, int dummy2 );
  void showResultImg();

  /*--------------------------*/
  /* Loading/Adding Detectors */
  /*--------------------------*/
  void addDetector();
  void addDetector( QString sDetFile, bool bVerbose=true );

  void detectorTableClicked ( int nRow, int nCol, int button, 
                              const QPoint& mousePos );
  void showDetectorWindow   ( int nIdx );
  void addDetectorTableEntry( string sCategory, string sPose, string sFlipped,
                              string sThresh, string sColor );
  void updateDetectorTable  ();

 /*---------------------*/
  /* Loading/Adding Cues */
  /*---------------------*/
  void cueTableClicked    ( int nRow, int nCol, int button, 
                            const QPoint& mousePos );
  void showCueWindow      ( int nIdx );
  void addCueTableEntry   ( string sDetector, string sFeature, string sFlipped,
                            string sNumCl, string sNumOcc );
  void updateCueTableEntry( unsigned nIdx, string sDetector, 
                            string sFeature, string sFlipped,
                            string sNumCl, string sNumOcc );

  /*--------------------*/
  /* Extracting Patches */
  /*--------------------*/
  void collectCueInformation      ();
  void processImage               ( QString qstr );
  void collectPatches             ( bool process = false );

  void drawInterestPoints         ();
  void drawInterestPointsEllipse  ( float dScaleFactor );
  void displayPatchesForBrowsing  ( vector<OpGrayImage> &vPatches,
                                    int pos_x = 1150, int pos_y = 200 );

  /*-------------------------------------*/
  /* Comparing Patches with the Codebook */
  /*-------------------------------------*/
  void compareFeatures();

  /*-------------------------*/
  /* Processing a Test Image */
  /*-------------------------*/
  /* calling routines from ism.hh */
  void processTestImg     (  QString qsFileName, int nImgNumber,
                             vector<Hypothesis>  &vResultHyposSingle,
                             vector<Hypothesis>  &vResultHyposTight,
                             vector<OpGrayImage> &vImgSegment,
                             vector<OpGrayImage> &vImgPFig,
                             vector<OpGrayImage> &vImgPGnd,
                             bool bDisplayResults );

  /* in mcmatcher-experiments.cc */
  void processTestImgBothDir( QString qsFileName, int nImgNumber,
                              vector<Hypothesis>  &vResultHyposSingle,
                              vector<Hypothesis>  &vResultHyposTight,
                              vector<OpGrayImage> &vImgSegment,
                              vector<OpGrayImage> &vImgPFig,
                              vector<OpGrayImage> &vImgPGnd,
                              bool bDisplayResults );

  void processTestImgStd ();
  void processTestImgStd ( QString qsFileName );
  void processTestImgStd ( QString qsFileName, int nImgNumber,
                           vector<Hypothesis>  &vResultHyposSingle,
                           vector<OpGrayImage> &vImgSegment,
                           vector<OpGrayImage> &vImgPFig,
                           vector<OpGrayImage> &vImgPGnd,
                           ofstream &ofileSingle,
                           bool bDisplayResults=true );
  void processTestImgIDL ( QString qsFileName, int nImgNumber,
                           QString qsResultDir,
                           vector<Hypothesis> &vResultHypos,
                           ImgDescr &idInitial,
                           ImgDescr &idTight,
                           bool bDisplayResults=true );

  void displayRecoResults( const vector<Hypothesis>  &vResultHypos,
                           const vector<OpGrayImage> &vResultImgSeg,
                           const vector<OpGrayImage> &vResultImgPFig,
                           const vector<OpGrayImage> &vResultImgPGnd,
                           bool bDisplayResults=true );

  Hypothesis         computeTightBBox  ( OpGrayImage imgSeg, 
                                         int nOffX=0, int nOffY=0 );

  void               countPatches( Hypothesis &hypo, unsigned nIdx,
                                   const vector<HoughVote> &vSupporting );

  /* in mcmatcher-experiments.cc */
  void resampleHypothesis( Hypothesis &hypo, Segmentation &segResult );

  /*---------------------*/
  /* Loading Silhouettes */
  /*---------------------*/
  /* routines from scmatcher-verification.cc */
  void loadSilhouettes();

  /*-------------------------*/
  /* Hypothesis Verification */
  /*-------------------------*/
  /* routines from scmatcher-verification.cc */
  //void verifyHyposChamfer ( const vector<Hypothesis> &vInitialHypos,
  //                          vector<Hypothesis>       &vVerifiedHypos,
  //                          vector<QImage>           &vResultQImgs );
  void verifyHyposTemplate( const vector<Hypothesis> &vInitHypos,
                            const vector<Hypothesis> &vInitHyposTight,
                            const vector<OpGrayImage> &vResultImgSeg,
                            const vector<OpGrayImage> &vResultImgPFig,
                            const vector<OpGrayImage> &vResultImgPGnd,
                            vector<Hypothesis>       &vVerifiedHypos,
                            vector<Hypothesis>       &vVerifiedHyposTight,
                            vector<EdgePtVec>        &vVerifiedTemplates,
                            vector<int>              &vVerifiedTemplIds,
                            vector<QImage>           &vResultQImgs );

  double compBhattaMask   ( const OpGrayImage &img, 
                            const OpGrayImage &mask, 
                            int nShiftX, int nShiftY );

  /*----------------------*/
  /* Supporting Functions */
  /*----------------------*/
  void drawHypothesis            ( const Hypothesis &hypo, const QColor &col, 
                                   bool bPermanent );
  void refreshSrcImg             ();
  void displayResultImg          ( const QImage &qimg );
  void displayResultImg          ( const QImage &qimg, OpGrayImage img );

  void displayScaleFootprint     ();

  int  transformPoint            ( InterestPoint &ipt );
  int  transformPoint            ( int w, int h );
  
  float computeBoundingBoxOverlap ( Hypothesis h1, Hypothesis h2 );

  /*-------------*/
  /* Test Series */
  /*-------------*/
  void performIDLTestSeries();
  void performIDLTestSeries( QString qsExpFile, QString qsResultFile1,
                             QString qsSaveDirName="", 
                             QString qsTextResultFile="" );
  void performIDLTestSeries( ImgDescrList &idlExperiment, 
                             QString qsExpPath,
                             QString qsResultFile1,
                             QString qsSaveDirName="", 
                             QString qsTextResultFile="" );

  void processImageSeries();
  void loadExperimentFile( QString qsFileName, 
                           vector<string> &vImgNames, 
                           vector< vector<Hypothesis> > &vvAnnots );

  void listenToSocket();

  /*------------------------*/
  /* Experimental Functions */
  /*------------------------*/
  //void testMatching( unsigned nDet=0, unsigned nCue=0 );

  /*----------*/
  /* File I/O */
  /*----------*/
  /* routines from scmatcher-fileio.cc */
  void saveImages();
  void saveSegmentationsMatlab();
  //void saveSegmentationsMatlab( QString qsFileName );
  void savePFigPGndMatlab( GrayImage imgPFig, GrayImage imgPGnd,
                           string sFileName );

  QStringList getFileList( );
  QStringList getFileList( string sDir, string sCaption );

  bool readVector( string sFileName, FeatureVector &fvVector );
  bool readMatrix( string sFileName, vector<FeatureVector> &mMatrix );

  void saveImage( OpGrayImage img, string sFileName );
  void saveImageAscii( GrayImage img, string sFileName );
  OpGrayImage loadImageAscii( string sFileName );

  void writeResultsToDiskUIUC( ofstream &ofile, int nImgNumber,
                               vector<Hypothesis> vHypos );

  void writeResultsToDiskScore( ofstream &ofile, int nImgNumber,
                                vector<Hypothesis> vHypos );

  /*------------*/
  /* Parameters */
  /*------------*/
  void loadParams( bool bVerbose=false );
  void loadParams( string sFileName, bool bVerbose=false );
  void saveParams( bool bVerbose=false );
  void saveParams( string sFileName, bool bVerbose=false );
  
  RecoParams& getRecoParams( unsigned idx ) 
  { assert( idx<m_nNumDetectors ); return m_vParReco[idx]; }

  /**************************/
  /*   Interface Handlers   */
  /**************************/
signals:
  void sigMapThreshChanged         ( const QString& );
  void sigImgScaleChanged          ( const QString& );
  void sigWorldScaleChanged        ( const QString& );
  void sigAgreeingChanged          ( const QString& );
  void sigFromChanged              ( const QString& );
  void sigToChanged                ( const QString& );
  void sigMaxOverlapChanged        ( const QString& );
  void sigMinPFigChanged           ( const QString& );
  void sigWeightPFigChanged        ( const QString& );
  void sigMinPFigRefinedChanged    ( const QString& );

public:
  CBTable     m_mActiveCBs;
  MatchTable  m_mActiveMatches;
  MatchTable  m_mActiveMatchesL;

public:
  QCheckBox   *chkGrayConv;
  QCheckBox   *chkGammaNorm;

  QCheckBox   *chkDrawMaps;
  QCheckBox   *chkDrawConf;
  QCheckBox   *chkTightBB;
  QCheckBox   *chkEvalUnique;

  QCheckBox   *chkShowTxtSteps;
  QCheckBox   *chkShowTxtDet;
  QCheckBox   *chkShowTxtVot;
  QCheckBox   *chkShowTxtMDL;
  QCheckBox   *chkShowTimings;
  QCheckBox   *chkShowIntPts;

  QCheckBox   *chkDispVS;
  QCheckBox   *chkDispSup;
  QCheckBox   *chkDispSeg;
  QCheckBox   *chkDispMC;

  QCheckBox   *chkRefineHypo;
  QCheckBox   *chkWriteResult;
  QCheckBox   *chkWriteSeg;

  QCheckBox   *chkDoMDL;
  QCheckBox   *chkRejectOverlap;
  QCheckBox   *chkRejectPFig;
  QCheckBox   *chkResample;

private:
  QtResizeImg *rsSourceImg;
  QtResizeImg *rsResultImg;
  QtResizeImg *rsResultImg2;
  //QtResizeImg *vrsPoseImgs[NUM_POSES];

  QImage      m_img;
  QImage      m_qsourceImg;
  QImage      m_qresultImg;
  OpGrayImage m_grayImg;
  OpGrayImage m_grayImgMap;
  OpGrayImage m_resultImg;
  OpGrayImage m_gradMagImg;

  QString     m_qsLastImage;
  QString     m_qsLastCB;

  Calibration m_calCamera;
  bool        m_bCalibAvailable;

  vector<OpGrayImage>   m_vImagePatches;
  
  typedef vector<int> vecint;
  vector< vector<int> > m_vAllBelongingFV;

  vector<QString>       m_qimageList;
  
  PointVector               m_vPoints; 

  vector<PointVector>            m_vvPointsInside;
  vector<vector<FeatureVector> > m_vvFeatures;
  vector<MatchingInfo>           m_vMatchResults;

  vector<PointVector>            m_vvPointsInsideLeft;
  vector<vector<FeatureVector> > m_vvFeaturesLeft;
  vector<MatchingInfo>           m_vMatchResultsLeft;

  unsigned                m_nNumCues;
  vector<FeatureCue>      m_vCues;
  vector<bool>            m_vProcessBothDir;
  vector< vector<int> >   m_vvCueIdx;

  Codebook                m_cbCodebook;
  //vector<Codebook>      m_vCodebooks;
  //vector<ISM>           m_vISMReco;
  //ISM                   m_ismMultiCueLeft;
  ISM                     m_ismMDL;

  unsigned                m_nNumDetectors;
  vector<Detector>        m_vDetectors;

  vector<RecoParams>      m_vParReco;
  vector<CueWidget*>      m_vpCueWindows;
  vector<DetectorWidget*> m_vpDetectorWindows;

  bool    m_bShowGUI;

  string  m_sImgNameShort;
  string  m_sImgName;
  string  m_sImgPath;
  string  m_sImgFullName;
  string  m_sFileName;
  bool    m_bMapsOn;
  bool    m_bMapsOnManually;
  bool    m_bDrawMatchedPs;
  bool    m_bShowTxtSteps;
  bool    m_bShowTxtDetails;
  bool    m_bShowTxtVoting;
  bool    m_bShowTxtMDL;
  bool    m_bShowTimings;
  bool    m_bShowIntPts;
  bool    m_bDisplayVS;
  bool    m_bDisplaySupport;
  bool    m_bDisplaySegment;
  bool    m_bDisplayMultiCue;
  QString  m_qsDefResultFile; 

  RecoParams     m_parReco;
  //int    m_nFeatureType;

  bool   m_bBetterGrayConv;
  bool   m_bPerformGammaNorm;
  bool   m_bUse3DContext;
  bool   m_bPatchSizeFactor;
  bool   m_bUsePatches;

  /* Segmentation parameters */
  bool   m_bDrawConfidence;
  bool   m_bUseMapThresh;
  float  m_dMapThresh;
  bool   m_bOnlyUseFigure;
  bool   m_bOnlyAgreeingPatches;
  bool   m_bEvalUniqueContrib;

  /* Occurrence parameters */
  //int    m_nCateg;
  //int    m_nPose;
  bool   m_bSavePose;

  /* Recognition parameters */
  bool   m_bRefineHypothesis;
  bool   m_bWriteResults;
  bool   m_bWriteSegs;
  bool   m_bWriteDetections;
  bool   m_bDrawRejectedHypos;
  bool   m_bDrawTightBB;

  /* Multi-cue combination */
  int    m_nCombiMethod;//

  /* MDL parameters */
  bool   m_bDoMDL;
  bool   m_bRejectOverlap;
  float  m_dMaxOverlap;
  bool   m_bRejectPFig;
  float  m_dMinPFig;
  float  m_dMinPFigRefined;
  float  m_dWeightPFig;
  bool   m_bResampleHypos;

  /* Hypothesis verification */
  VeriParams     m_parVeri;

  /* Ground plane */
  int    m_nGPFrame;
  float  m_dImgScale;
  float  m_dWorldScale;

  bool   m_bSilhouettesLoaded;
  vector<OpGrayImage> m_vSilhouettes;
  vector<QImage>      m_vQSilhouettes;
  vector<OpGrayImage> m_vSilhMasks;
  vector<EdgePtVec>   m_vTemplates;
  vector<EdgePtVec>   m_vTemplatesOrig;

  vector<HoughVote>   m_vActiveVotes;

  vector<Hypothesis>  m_vHyposSingle;

  /* cue & detector table */
  QTable             *m_tblCues;
  QTable             *m_tblDetectors;

  /* result visualization */
  QtClusterView      *m_qcvResultView;
};

 

#endif
