/*********************************************************************/
/*                                                                   */
/* FILE         scmatcher.hh                                         */
/* AUTHORS      Bastian Leibe                                        */
/* EMAIL        leibe@informatik.tu-darmstadt.de                     */
/*                                                                   */
/* CONTENT      Interleaved Object Categorization and Segmentation   */
/*              with an Implicit Shape Model.                        */
/*              The program performs simultaneous recognition and    */
/*              segmentation of canonical views of categorical ob-   */
/*              jects, such as sideviews of cars or cows. Prior to   */
/*              recognition, a codebook of local appearance must be  */
/*              generated by the 'clusterer' program. This version   */
/*              of the code currently just handles objects at a      */
/*              single scale.                                        */
/*                                                                   */
/*              An explanation of the algorithm can be found in the  */
/*              following papers:                                    */
/*                                                                   */
/*              Bastian Leibe and Bernt Schiele,                     */
/*              Interleaved Object Categorization and Segmentation.  */
/*              In Proc. British Machine Vision Conference (BMVC'03) */
/*              Norwich, GB, Sept. 9-11, 2003.                       */
/*                                                                   */
/*              Bastian Leibe and Bernt Schiele,                     */
/*              Combined Object Categorization and Segmentation with */
/*              an Implicit Shape Model.                             */
/*              submitted to ECCV'04 Workshop on Statistical Lear-   */
/*              ning in Computer Vision, Prague, May 2004.           */
/*                                                                   */
/* BEGIN        Tue Nov 05 2002                                      */
/* LAST CHANGE  Sat Jul 03 2004                                      */
/*                                                                   */
/*********************************************************************/

#ifndef SCMATCHER_HH
#define SCMATCHER_HH

using namespace std;

/****************/
/*   Includes   */
/****************/
#include <qwidget.h>
#include <qstring.h>
#include <qimage.h>

#include <qtresizeimg.hh>
#include <qtclusterview.hh>
#include <opgrayimage.hh>
#include <opinterestimage.hh>
#include <featurevector.hh>
#include <nnsearch.hh>
#include <histogram.hh>
#include <visualhistogram.hh>
#include <cluster.hh>
#include <clstep.hh>
#include <pyramidscalespace.hh>
#include <imgdescrlist.hh>
#include <votingspace.hh>
#include <chamfermatching.h>
#include <occurrences.hh>
#include <codebook.hh>
#include <ism.hh>
#include <featuregui.hh>
#include <featurecue.hh>
#include <recogui.hh>
#include <recoparams.hh>
#include <matchinggui.hh>
#include <matchingparams.hh>

#include "verigui.hh"
#include "veriparams.hh"

//#include "parts.hh"

/*******************/
/*   Definitions   */
/*******************/
const string STR_NAME         = "ScaleMatcher";
const string STR_VERSION      = "1.9";

const float FACTOR_SIM_EDGESIFT = 800.0;  

const string DIR_IMAGES       = "/home/bleibe/images";
const string DIR_CODEBOOKS    = "/home/bleibe/projects/patches/experiments-cvpr06/codebooks";
//const string DIR_CODEBOOKS    = "/local/leibe/codebooks";
const string DIR_CL_RESULTS   = "/home/bleibe/projects/patches/experiments-cvpr06";
const string DIR_CL_FVECS     = "/home/bleibe/projects/patches/experiments-cvpr06";
const string DIR_SAVED_IMAGES = "/home/bleibe/projects/patches/experiments-cvpr06/saved-images";
const string DIR_EXPERIMENTS  = "/home/bleibe/images/real-world/testsets-bmvc";
const string DIR_RESULTS      = "/home/bleibe/projects/patches/experiments-eccv06/results";

const string DIR_UIUC_DB      = "/home/bleibe/images/test-data/uiuc-car-data/TestImages/resized2.5/";
const string DIR_UIUC_DATA    = "/home/bleibe/images/test-data/uiuc-car-data/TestImages/";

const string DIR_SILHOUETTES  = "/home/bleibe/images/training-data/pedestrians/silhouettes-210imgs-both-150";

const int    NUM_UIUC_IMAGES  = 170;


const float GM_SIGMA       = 1.0; // sigma used for gradient magnitude

const bool  OVERDRAW_IMG   = true; //draw interest points over source image

const float EPS_PFIG          = 0.0001;

const int SIZE_VOTINGBINS     = 10;

//const int OBJDIM_WIDTH  = 0;
//const int OBJDIM_HEIGHT = 1;


struct compPairDecr
{
  bool operator()( const pair<float,int> &x, const pair<float,int> &y )
  { return (x.first > y.first); }
};

/*--------*/
/* Result */
/*--------*/
typedef struct _Result
{
public:
  int   nRank;
  float dDistX;
  float dDistY;
  float dDist;
  float dCover;
  float dOverlap;
} Result;


class ISMReco: public QWidget
{
  Q_OBJECT
public:
  ISMReco( QWidget *parent=0, const char *name=0 );
  
public slots:
  /**************************/
  /*   Interface Handlers   */
  /**************************/
  void slotSetMapThresh         ( const QString &text );
  void slotUpdateMapThresh();

  void slotSetCateg             ( const QString &text );
  void slotSetPose              ( const QString &text );
  void slotSetUIUCFrom          ( const QString &text );
  void slotSetObjWidth          ( const QString &text );
  void slotSetObjHeight         ( const QString &text );
  void slotUpdateCateg();
  void slotUpdatePose();
  void slotUpdateUIUCFrom();
  void slotUpdateObjWidth();
  void slotUpdateObjHeight();

  void slotSelectFixObjDim       ( int   id );

  void slotSetHistEqOnOff        ( int   state );
  void slotSetUsePatchesOnOff    ( int   state );
  void slotSetMapsOnOff          ( int   state );
  void slotSetDrawConfOnOff      ( int   state );
  //void slotSetMapThreshOnOff     ( int   state );
  void slotSetDrawMatchedPsOnOff ( int   state );
  void slotSetFigureOnOff        ( int   state );
  void slotSetDrawTightBBOnOff   ( int   state );
  void slotSetDisplayVSOnOff     ( int   state );
  void slotSetDisplaySupportOnOff( int   state );
  void slotSetDisplaySegmentOnOff( int   state );
  //void slotSetPatchSizeFactOnOff ( int   state );
  void slotSetSavePoseOnOff      ( int   state );
  void slotSetRefineHypoOnOff    ( int   state );
  void slotSetWriteDetectOnOff   ( int   state );
  void slotSetDrawRejectedOnOff  ( int   state );

  /*************************/
  /*   Regular Functions   */
  /*************************/
  /*--------------------------*/
  /* Loading Images/Codebooks */
  /*--------------------------*/
  void loadImage      (); 
  void loadImage      ( QString qsFileName );
  void loadImageBBox  ( QString qsName, const Rect &rBBox );

  void loadCodebook   ();
  void loadCodebook   ( string sFileName );

  /*--------------------*/
  /* Extracting Patches */
  /*--------------------*/
  void processImage               ( QString qstr );
  void processImageBBox           ( QString qstr, const Rect &rBBox );
  void collectPatches             ( bool process = false );

  void drawInterestPoints         ();
  void drawInterestPointsEllipse  ();
  void displayPatchesForBrowsing  ( vector<OpGrayImage> &vPatches,
                                    int pos_x = 1150, int pos_y = 200 );
  void highlightPoint             ( int idx );

  /*-------------------------------------*/
  /* Comparing Patches with the Codebook */
  /*-------------------------------------*/
  void compareFeatures();
  void compareFeatures( bool bShowPatches );

  void testMatching();

  /*-----------------------*/
  /* Computing Occurrences */
  /*-----------------------*/
  /* calling routines from ism.hh */
  void computeOccurrences();
  void computeOccurrencesIDL();
  void computeOccurrencesIDL( const QString& qsIdlFile );
  void saveOccurrences();
  void saveOccurrencesMatlab();
  void loadOccurrences();

  /*-----------------------*/
  /* Computing Silhouettes */
  /*-----------------------*/
  /* routines from scmatcher-verification.cc */
  void loadSilhouettes();

  /*-------------------------------*/
  /* Loading the Verification Data */
  /*-------------------------------*/
  /* routines from scmatcher-verification.cc */
  void loadVerifCodebook();
  void loadVerifOccurrences();

  /*-------------------------*/
  /* Processing a Test Image */
  /*-------------------------*/
  /* calling routines from ism.hh */
  void processTestImg     (  QString qsFileName, int nImgNumber,
                             vector<Hypothesis>  &vResultHyposSingle,
                             vector<Hypothesis>  &vResultHyposTight,
                             vector<OpGrayImage> &vImgSegment,
                             vector<OpGrayImage> &vImgPFig,
                             vector<OpGrayImage> &vImgPGnd,
                             bool bDisplayResults );

  void processTestImgStd ();
  void processTestImgStd ( QString qsFileName, int nImgNumber,
                           vector<Hypothesis> &vResultHyposSingle,
                           ofstream &ofileSingle,
                           bool bDisplayResults=true );
  void processTestImgUIUC( QString qsFileName, int nImgNumber,
                           vector<Hypothesis> &vResultHyposSingle,
                           ofstream &ofileSingle, ofstream &ofScore,
                           bool bDisplayResults=true );
  void processTestImgIDL ( QString qsFileName, int nImgNumber,
                           vector<Hypothesis> &vResultHypos,
                           ImgDescr &idInitial,
                           ImgDescr &idTight,
                           bool bDisplayResults=true );

  void displayRecoResults( const vector<Hypothesis>  &vResultHypos,
                           const vector<OpGrayImage> &vResultImgSeg,
                           bool bDisplayResults=true );

  /* calling routines from ism.hh */
  vector<Hypothesis> getPatchHypotheses     ( bool bDisplayResults=true );  

  vector<Hypothesis> setHypoBBox            ( const vector<Hypothesis> &vHypos,
                                              int nObjWidth, int nObjHeight );
  vector<HoughVote>  filterVotes            ( const Hypothesis &hypo, 
                                              const vector<HoughVote> &vVotes);
  Hypothesis         computeTightBBox       ( OpGrayImage imgSeg, 
                                              int nOffX=0, int nOffY=0 );

  /*-------------------------*/
  /* Hypothesis Verification */
  /*-------------------------*/
  /* routines from scmatcher-verification.cc */
  void verifyHyposHarris  ( const vector<Hypothesis> &vInitialHypos,
                            vector<Hypothesis>       &vVerifiedHypos,
                            vector<Hypothesis>       &vVerifiedHyposTight,
                            vector<QImage>           &vResultQImgs );
  void verifyHyposChamfer ( const vector<Hypothesis> &vInitialHypos,
                            vector<Hypothesis>       &vVerifiedHypos,
                            vector<QImage>           &vResultQImgs );
  void verifyHyposTemplate( const vector<Hypothesis> &vInitHypos,
                            const vector<Hypothesis> &vInitHyposTight,
                            const vector<OpGrayImage> &vResultImgSeg,
                            const vector<OpGrayImage> &vResultImgPFig,
                            const vector<OpGrayImage> &vResultImgPGnd,
                            vector<Hypothesis>       &vVerifiedHypos,
                            vector<Hypothesis>       &vVerifiedHyposTight,
                            vector<EdgePtVec>        &vVerifiedTemplates,
                            vector<int>              &vVerifiedTemplIds,
                            vector<QImage>           &vResultQImgs );

  double compBhattaMask   ( const OpGrayImage &img, 
                            const OpGrayImage &mask, 
                            int nShiftX, int nShiftY );

  /*-------------------------------*/
  /* Refinement (Uniform Sampling) */
  /*-------------------------------*/

  void refineHypotheses          ( bool bDisplayResults=true );
  void refineHypothesesMultiScale( bool bDisplayResults=true );

  void extractAllPatches         ( bool process=false ); // temporary only

  /*----------------------*/
  /* Supporting Functions */
  /*----------------------*/
  void showSupportingPatches     ( int page, int x, int y );
  void showSupportingPatches     ( FeatureVector fvWindowPos, 
                                   bool bDrawMaps=false );

  OpGrayImage drawMatchedPatches ();
  void        displayVotePatches ( vector<HoughVote> vVotes, 
                                   bool bDrawMaps=false,
                                   bool bDrawConfidence=false, 
                                   bool bDrawFigure=true );
  OpGrayImage drawVotePatches    ( vector<HoughVote> vVotes, 
                                   bool bDrawMaps=false,
                                   bool bDrawConfidence=false, 
                                   bool bDrawFigure=true,
                                   bool bBackgroundZero=false );
  void displayVoteConfidence     ( vector<HoughVote> vVotes, 
                                   bool bDrawMaps=false );
  void displayScaleFootprint     ();

  int  transformPoint            ( InterestPoint &ipt );
  int  transformPoint            ( int w, int h );
  
  float computeBoundingBoxOverlap ( Hypothesis h1, Hypothesis h2 );

  /*-------------*/
  /* Test Series */
  /*-------------*/
  void performUIUCTestSeries();
  void performIDLTestSeries();

  void processImageSeries();
  void loadExperimentFile( QString qsFileName, 
                           vector<string> &vImgNames, 
                           vector< vector<Hypothesis> > &vvAnnots );

  /*----------*/
  /* File I/O */
  /*----------*/
  /* routines from scmatcher-fileio.cc */
  void saveFVMatlab();
  void saveClustersMatlab();
  void savePatchActivationsMatlab();

  void saveImages();
  void saveSegmentationsMatlab();
  void saveSegmentationsMatlab( QString qsFileName );

  void saveClusterImages();

  void saveTextureMap();
  void saveSegmentationData();

  QStringList getFileList( );
  QStringList getFileList( string sDir, string sCaption );

  bool readVector( string sFileName, FeatureVector &fvVector );
  bool readMatrix( string sFileName, vector<FeatureVector> &mMatrix );

  void saveImage( OpGrayImage img, string sFileName );
  void saveImageAscii( GrayImage img, string sFileName );
  OpGrayImage loadImageAscii( string sFileName );

  void writeResultsToDiskUIUC( ofstream &ofile, int nImgNumber,
                               vector<Hypothesis> vHypos );

  void writeResultsToDiskScore( ofstream &ofile, int nImgNumber,
                                vector<Hypothesis> vHypos );

  /*------------*/
  /* Parameters */
  /*------------*/
  void loadParams( bool bVerbose=false );
  void loadParams( string sFileName, bool bVerbose=false );
  void saveParams( bool bVerbose=false );
  void saveParams( string sFileName, bool bVerbose=false );
  
  /**************************/
  /*   Interface Handlers   */
  /**************************/
signals:
  void sigMapThreshChanged         ( const QString& );
  void sigAgreeingChanged          ( const QString& );
  void sigFromChanged              ( const QString& );
  void sigToChanged                ( const QString& );
  void sigCategChanged             ( const QString& );
  void sigPoseChanged              ( const QString& );
  void sigUIUCFromChanged          ( const QString& );
  void sigObjWidthChanged          ( const QString& );
  void sigObjHeightChanged         ( const QString& );

private:

  QtResizeImg *rsSourceImg;
  QtResizeImg *rsResultImg;
  //QtResizeImg *vrsPoseImgs[NUM_POSES];

  QImage      m_img;
  QImage      m_qsourceImg;
  QImage      m_qresultImg;
  OpGrayImage m_grayImg;
  OpGrayImage m_grayImgMap;
  OpGrayImage m_resultImg;
  OpGrayImage m_gradMagImg;
  QString     m_qsLastImage;
  QString     m_qsLastIDL;


  vector<OpGrayImage>   m_vImagePatches;
  vector<FeatureVector> m_vFeatures;
  
  typedef vector<int> vecint;
  vector< vector<int> > m_vAllBelongingFV;

  vector<QString>       m_qimageList;
  
  PointVector               m_vPoints, m_vPointsInside;

  vector<int>               m_vNearestNeighbor;
  vector<float>             m_vNearestNeighborSim;
  vector< vector<int> >     m_vvAllNeighbors;
  vector< vector<float> >   m_vvAllNeighborsSim;

  Codebook       m_cbCodebook;
  Codebook       m_cbVerify;

  ISM            m_ismReco;
  ISM            m_ismVeri;

  string  m_sImgNameShort;
  string  m_sImgName;
  string  m_sImgPath;
  string  m_sImgFullName;
  string  m_sFileName;
  bool    m_bMapsOn;
  bool    m_bMapsOnManually;
  bool    m_bDrawMatchedPs;
  bool    m_bDisplayVS;
  bool    m_bDisplaySupport;
  bool    m_bDisplaySegment;

  FeatureCue     m_fcCue;
  FeatureCue     m_fcHarris;
  RecoParams     m_parReco;
  VeriParams     m_parVeri;
  ClusterParams  m_parCluster;
  MatchingParams m_parMatching;
  MatchingParams m_parVeriMatch;
  int    m_nFeatureType;

  bool   m_bPerformHistEq;
  bool   m_bPatchSizeFactor;
  bool   m_bUsePatches;

  /* Segmentation parameters */
  bool   m_bDrawConfidence;
  bool   m_bUseMapThresh;
  float  m_dMapThresh;
  bool   m_bOnlyUseFigure;
  bool   m_bOnlyAgreeingPatches;

  /* Occurrence parameters */
  int    m_nCateg;
  int    m_nPose;
  bool   m_bSavePose;

  /* Training data parameters */
  int     m_nFixObjDim;
  int     m_nObjWidth;
  int     m_nObjHeight;

  /* Recognition parameters */
  int    m_nUIUCFrom;

  bool   m_bRefineHypothesis;
  bool   m_bWriteDetections;
  bool   m_bDrawRejectedHypos;
  bool   m_bDrawTightBB;

  /* Hypothesis verification */
  bool   m_bSilhouettesLoaded;
  vector<OpGrayImage> m_vSilhouettes;
  vector<QImage>      m_vQSilhouettes;
  vector<OpGrayImage> m_vSilhMasks;
  vector<EdgePtVec>   m_vTemplates;
  vector<EdgePtVec>   m_vTemplatesOrig;

  vector<HoughVote>   m_vActiveVotes;

  vector<Hypothesis>  m_vHyposSingle;

  /* qticonbox */
  QtClusterView *qClassView;
};

 

#endif
